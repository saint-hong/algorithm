# 알고리즘 코딩 문제 풀기

# 001. 0 부터 n 까지의 숫자의 합 출력

### 1) 코드 작성 순서
- 1 이 아니라 0 부터 n 까지의 숫자를 순서대로 증가 시킨다.
- 숫자를 순서대로 증가 시키기 위해 반복문을 사용한다.
- 코드에 사용할 변수의 갯수를 미리 파악한다.

### 2) 골격 코드 skeleton code 를 우선 작성 한다.
- 숫자를 순서대로 증가시키기 위한 반복문 코드가 골격코드가 된다.
- 변수
    - i : 반복문을 제어하는 변수로 1 씩 증가하는 숫자를 저장한다.
    - sum : 증가하는 숫자를 저장한 i 를 합한 값을 저장하는 변수이다. 반복문이 종료되면 출력된다.

### 3) 순서도를 작성해 본다.
- 변수를 초기화 : i = 0, sum = 0
- 반복문의 제어 조건 설정 : i <= n
    - 반복문의 조건에 부합하지 않으면 sum 변수를 출력한다.
- 증가하는 숫자를 누적계산하는 코드 : sum = sum + i
- 숫자가 1 씩 증가하는 코드 : i = i + 1
    - 반복문의 처음으로 돌아간다.
- sum 변수 출력 : 반복문의 제어 조건에 맞지 않는 경우, 즉 i 가 n 보다 커지는 경우이다. 

### 4) 코드
```
def sumofnumber(n) :
    i = 0
    sum = 0
    while i <= n :
        sum = sum + i
        i = i + 1
    print(sum)

if __name__ == "__main__" :
    sumofnumber(372000)

=====<print>=====

69192186000
```

# 002. 재귀 호출을 사용하여 1부터 20까지 출력

### 1) 코드 작성 순서
- 1부터 출력한다.
- 재귀 호출을 빠져나오는 제어 조건을 명확하게 정의한다.
- 재귀 함수의 호출문장과 재귀 함수의 처리 문장의 실행 순서를 명확하게 정의한다.

### 2) 골격 코드 작성
- 반복문을 사용하지 않는다.
- 재귀 호출을 빠져나오는 제어문을 포함시킨다.
- 함수를 호출하는 문장 후
- 함수를 처리하는 문장을 넣는다.

### 3) 재귀호출의 특징
- 재귀호출은 함수의 호출 문장과 처리 문장의 순서와 재귀호출을 빠져나오는 제어문이 중요하다.
- 이러한 것만 잘 설정해준다면, 반복문보다 논리적으로 훨씬 간결해지는 장점이 있다.

### 4) code
```
def sumofnumber_recursive(n) :
    if n > 0 :                         # 재귀 호출의 제어문 
        sumofnumber_recursive(n-1)     # 함수를 호출하는 문장
    print(n)                           # 함수를 처리하는 문장 

if __name__ == "__main__" :
    sumofnumber_recursive(20)

=====<print>=====

0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
```
```
# 함수 호출 문장과 함수 처리 문장의 순서가 바뀌면 출력되는 숫자가 역순이 된다.

def sumofnumber_recursive_2(n) :
    if n > 0 :
        print(n)
        sumofnumber_recursive_2(n-1)

if __name__ == "__main__" :
    sumofnumber_recursive_2(20)


=====<print>=====

20
19
18
17
16
15
14
13
12
11
10
9
8
7
6
5
4
3
2
1
```
# 003. 반복문을 사용하여 1부터 n까지 출력

### 1) 코드 작성 순서
- 반복문의 제어문의 변수를 정의한다.
- 반복문을 정의한다.
- 변수가 n 보다 작은지 큰지를 비교한다.
- 변수 c 를 출력한다.
- 변수 c 를 증가시킨다.

### 2) 골격 코드 작성
- 변수 설정
- 반복문 작성
- 반복문의 제어문 작성
- 변수 출력
- 변수 증가

### 3) 주의 사항
- 초기값 설정 : 변수를 1로 정의한다.
- 마지막값 설정 : 제어문의 조건에 부등호를 확인한다.

### 4) code
```
c = 1
while c <= 20 :
    print(c)
    c = c + 1

=====<print>=====

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
```
### 5) for 문을 사용하여 출력
- for 문은 리스트, 튜플, 딕셔너리, 문자열을 사용하여 순차적으로 변수에 담을 수 있다.

```
lst_type = [1,2,3,4,5,6,7,8,9,10]

for x in lst_type :
    print(x)

=====<print>=====

1
2
3
4
5
6
7
8
9
10
```
```
tuple_type = (1,2,3,4,5,6,7,8,9,10)

for x in tuple_type :
    print(x)

=====<print>=====

1
2
3
4
5
6
7
8
9
10
```
```
dict_type = {'key_1':1, 'key_2':2, 'key_3':3, 'key_4':4, 'key_5':5}

for x in dict_type :
    print(x)
    print(dict_type[x])

=====<print>=====

key_1
1
key_2
2
key_3
3
key_4
4
key_5
5
```
```
for x in 'abcdefghi' :
    print(x)

=====<print>=====

a
b
c
d
e
f
g
h
i
```
# 004. 재귀 호출을 사용하여 1부터 n까지 출력

### 1) 코드 작성 순서
- 함수 설정
- 함수내부의 실행코드 작성
- 재귀 호출의 제어문 작성
- 함수의 처리 문장과 함수의 호출 문장의 순서를 고려하여 작성

### 2) 골격 코드
- 재귀 호출의 제어문
- 출력문
- 함수의 호출문 : 값이 감소된 아규먼트를 넣는다.
    
### 3) 주의 사항
- 재귀 호출은 재귀 함수를 종료하는 조건이 중요하다.
- 재귀 함수의 종료 조건이 잘 못되면 무한 루프에 빠지게 된다.
- 함수의 처리 문장과 호출 문장의 순서를 잘 설정해야 한다.

### 4) code
```
def print_to_number(n) :
    if n >= 1 :
        print(n)
        print_to_number(n-1)
        #print(n)

if __name__ == "__main__" :
    print_to_number(10)

=====<print>=====

10
9
8
7
6
5
4
3
2
1
```
- 재귀호출 다음에 출력문이 오면 결과가 반대로 된다.
```
def print_to_number_2(n) :
    if n > 0 :
        print_to_number_2(n-1)
        print(n)

if __name__ == "__main__" :
    print_to_number_2(10)

=====<print>=====

1
2
3
4
5
6
7
8
9
10
```
- print 명령어가 제어조건보다 선행해도 출력결과는 같다.
```
def print_to_number_3(n) :
    print(n)
    if n >= 1 :
        print_to_number_3(n-1)

if __name__ == "__main__" :
    print_to_number_3(10

=====<print>=====

10
9
8
7
6
5
4
3
2
1
0
```
# 005. 3과 5의 배수 계산하기

### 1) 접근방법 및 조건
- 배수 개념을 바로 알아야 한다. : 어떤 수 B를 A로 나누었을 때 나머지가 0 이면 B는 A의 배수이다.
- 배수를 확인과 반복문을 묶어서 설계해야한다.
- 조건 :
    - 배수의 개넘을 코드로 만들어야한다.
    - 3의 배수이면서 5의 배수인지를 확인하는 코드를 만들어야한다.
    - 반복문을 사용하여 1부터 n까지 1씩 증가하면서 제어 변수를 확인한다.

### 2) code

#### 조건 1 : 조건문에 나머지 연산자를 사용하여 3의 배수인지를 확인하는 코드
```
def f(n) :
    if n % 3 == 0 :
        print("n은 3의 배수이다.")
    else :
        print("n은 3의 배수가 아니다.")

f(10)

=====<print>=====

n은 3의 배수가 아니다.

f(15)

=====<print>=====

n은 3의 배수이다.
```
#### 조건 2 : 나머지 연산자를 3과 5의 경우로 나누고 조건문에 and 를 사용하여 3과 5의 배수인지를 확인한다.
- 조건문을 세분화하여 나타낼 수 있다.
```
def f(n) :
    if (n % 3 == 0) and (n % 5 == 0) :
        print("n은 3과 5의 배수이다.")
    elif n % 3 == 0 :
        print("n은 3의 배수이다.")
    elif n % 5 == 0 :
        print("n은 5의 배수이다.")
    else :
        print("n은 3, 5의 배수가 아니다.")

f(15)

=====<print>====

n은 3과 5의 배수이다.

f(9)

=====<print>=====

n은 3의 배수이다.

f(25)

=====<print>=====

n은 5의 배수이다.

f(8)

=====<print>=====

n은 3, 5의 배수가 아니다.
```
#### 조건 3 : 반복문의 제어변수를 1씩 증가하면서 3과 5의 배수인 수를 출력한다.
```
def f(n) :
    i = 1
    while i <= n :
        if (i % 3 == 0) and (i % 5 == 0) :
            print("%d"%(i))
        i = i + 1     

f(100)

=====<print>=====

15
30
45
60
75
90
```
```
def check_common(n) :
    i = 1
    while i <= n :
        if i % 3 == 0 and i % 5 == 0 :
            print("%d"%(i))
        i = i + 1


check_common(100)

=====<print>=====

15
30
45
60
75
90
```
# 006. 숫자뒤집기

### 1) 접근방법 및 조건
- 입력 된 숫자를 뒤집어서 출력한다.
    - 123456 -> 654321
- 입력 된 숫자를 문자열 처럼 접근하여 뒤에서부터 출력하는 방식보다, 숫자의 자릿수를 찾아 출력하는 방식이 유용하다.
    - 문자열로 접근하게 되면, 입력받은 숫자를 str으로 바꿔주고, 반복문을 사용하여 뒤에서부터 출력하는 방식으로 접근하게 된다.
    
- 조건 :
    - 정수의 자릿수를 계산하는 방법을 생각해 본다.
    - 반복문 보다는 재귀호출을 사용하면 간단해진다.

### 2) code

#### 조건1 : 정수의 자릿수를 계산
- 어떤 수를 10을 나눈 나머지는 1의 자리의 숫자를 나타낸다.
- 어떤 수를 자릿수에 해당하는 값으로 나누어주면, 그 자릿수가 1의 자릿수가 되고, 이것을 10으로 나눈 나머지 값은 1의 자리의 숫자가 된다.
```
position_1 = 123 % 10
position_10 = (123/10) % 10
position_100 = (123/100) % 10


position_1

=====<print>=====

3

position_10, int(position_10)

=====<print>=====

(2.3000000000000007, 2)

position_100, int(position_100)

=====<print>=====

(1.23, 1)
```
#### 조건2 : 재귀호출의 사용
- 출력문에서 n 의 1의 자리숫자를 출력하도록 한다.
    - end='' 조건을 포함하지 않으면 각자리의 숫자가 세로로 출력된다.
    - 출력된 결과는 nontype 이다.
- 출력문 다음에 재귀호출을 사용한다.
- 재귀호출 시 아규먼트를 n 을 10으로 나눈 몫을 사용한다.
    - 이렇게 되면 1234 -> 123 -> 12 -> 1 로 n 의 자릿수가 하나씩 작아지게 된다.

```
def f(n) :
    if n == 0 :
        return 0
    print(n % 10, end='')
    f(n//10)

1234//10, 1234/10

=====<print>=====

(123, 123.4)

12345//10, 1234//10, 123//10, 12//10

=====<print>=====

(1234, 123, 12, 1)

f(23468594)

=====<print>=====

49586432
```

### 3) 최종코드
```
def solve(n) :
    if n == 0 :
        return n
    print(n % 10, end='')
    solve(n//10)

if __name__ == "__main__" :
    num_str = input("입력 : ")
    num = int(num_str)
    solve(num)

=====<print>=====

입력 : 645373927464
464729373546
```

### 4) 다른 접근
- 입력받은 숫자를 문자열로 접근했을 때 생각해 볼 수 있는 코드
- 재귀호출을 사용하는 방식이 더 간편하다!
- 여러개의 숫자를 리스트로 받을 경우는 다른 코드로 접근해야 한다.

#### 반복문과 reversed() 명령어를 사용하면 문자열의 뒤에서부터 하나씩 가져온다.
```
a = "78654"

for i in reversed(a) :
    print(i, end='')

=====<print>=====

45687
```
#### 반복문에 문자열의 길이보다 1작은 값을 뒤에서부터 차례로 꺼내고, 그 값을 문자열의 변수의 인덱스로 넣어준다.
```
a = "78654"
length = len(a)

for i in range(length-1,-1,-1) :
    print(a[i], end='')

=====<print>=====

45687


# range(start, end, step)
# end 는 출력되지 않는다.

print(list(range(5)))
print(list(range(0,5)))
print(list(range(0,5,2)))
print(list(range(5,0,-1)))

=====<print>=====

[0, 1, 2, 3, 4]
[0, 1, 2, 3, 4]
[0, 2, 4]
[5, 4, 3, 2, 1]
```

# 007. 369 게임 만들기

### 1) 접근방법 및 조건
- 3의 배수에 해당하는 숫자가 나오면 X를 출력하고, 3의 배수가 아닌 숫자는 그대로 출력한다.
- 앞에서 다룬 3의 배수와 5의 배수를 찾는 문제와 유사하다.
- 조건 :
    - 3의 배수를 확인하는 코드를 작성
    - 3의 배수가 아닌 경우는 숫자를 출력하고, 3의 배수인 경우는 X 를 출력하는 코드를 작성
    - 입력받은 숫자 n 까지 이 과정을 반복하도록 한다.

### 2) 코드

#### 조건1: 3의 배수를 확인하는 코드
```
def f(n) :
    if n % 3 == 0 :
        print("3의 배수")
    else :
        print("3의 배수가 아님")

f(10)

=====<print>=====

3의 배수가 아님


f(9)

=====<print>=====

3의 배수가 아님
```
#### 조건2 : 3의 배수가 아닌경우는 숫자를 출력하고, 3의 배수인 경우는 X 를 출력한다.
```
def f(n) :
    if n % 3 == 0 :
        print("3의 배수")
    else :
        print(n)


f(9)

=====<print>=====

3의 배수

f(10)

=====<print>=====

10
```

#### 조건3 : 입력받은 숫자 n 까지 3의 배수인지 아닌지를 확인하고 X 또는 숫자를 출력하도록 한다.
- 반복문을 사용
- 반복문의 제어문을 설정해준다.
```
def f(n) :
    i = 1
    while i <= n :
        if i % 3 == 0 :
            print("X")
        else :
            print(i)
        i = i + 1

f(20)

=====<print>=====

1
2
X
4
5
X
7
8
X
10
11
X
13
14
X
16
17
X
19
20
```

### 4) 최종 코드
- 3의 배수 또는 5의 배수인 경우는 X를 출력
```
def solve(n) :
    i = 1
    while i <= n :
        if (i % 3 == 0) or (i % 5 == 0) :
            print("X")
        else :
            print(i)
        i = i + 1

if __name__ == "__main__" :
    solve(20)

=====<print>=====

1
2
X
4
X
X
7
8
X
X
11
X
13
14
X
16
17
X
19
X
```
# 008. 자연수 n이 소수인지 아닌지를 출력하기

### 1) 접근풀이 및 조건
- 소수 prime number : 1보다 큰 자연수 중에서, 약수가 1과 자기 자신뿐인 수. (2,3,5,7,11,13 등)
    - 즉 소수인지를 확인하는 방법은 어떤 숫자가 1과 자기 자신을 제외한 다른 숫자로 나누어지는지 확인한다.
    - 소수의 반대는 합성수이다.
- 조건 :
    - 반복문을 사용하여 주어진 숫자 n을 2부터 n-1 까지 반복하면서 나눈다.
    - 나눈결과가 나눈몫을 구할 수 있으면 소수가 아닌 합성수이다.
    - 이 반복문이 끝난 결과로 제어 변수가 주어진 n과 같으면 소수이고 같지 않으면 합성수이다.

### 1)-1 정리
- n 까지 증가하는 반복문과 n 보다 작을 때까지 증가하는 제어문
    - i 가 증가하면서 n 과 같아지면 반복문을 빠져나온다.
- n 을 i 로 나누어서 나머지가 0 이면 반복문을 중단하는 조건문
    - i 가 n 보다 작은데 나머지가 0 이라는 것은 소수의 조건에 해당하지 않음
- 반복문이 종료되면 i 가 n 과 같은지 확인
    - i 가 n 과 같은면 n 은 소수, i 가 n 과 같지 않으면 n 은 합성수
- 반복문이 중단되는 경우는 2 가지이다.
    - 제어문의 조건인 i < n 이 아닌 경우. 즉 i = n 인 경우
    - if 문의 조건인 경우. n 이 자신보다 작은 숫자로 나누어 몫이 0 이 되는 경우

### 2) 코드

#### 조건1 : 숫자 n을 2부터 n-1 까지 반복하여 나누어지는지 확인

```
i = 2
n = 17
while i < n :       ### i 가 반복문을 통과하면 n-1일 될떄까지 1씩 증가한다.
    if n % i == 0 :  ### 조건 : n 을 i 로 나눈 몫이 0이면 while 문을 중지한다.
        break
    print(i)
    i = i + 1        ### if 조건에 부합할 떄까지 반복문을 통해서 i가 증가한다.

=====<print>=====

2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
```
#### 조건2 : 반복문이 끝난 결과가 제어변수 n과 같으면 소수이고 같지 않으면 합성수 이다.

```
if i == n :
    print("n은 소수")
else :
    print("n은 합성수")

=====<print>=====

n은 소수
```

### 3) 최종 코드
```
def check_primenum(n) :
    i = 2
    while i < n :
        if n % i == 0 :
            break
        i = i + 1
    if i == n :
        print("{}은 소수".format(n))
    else :
        print("{}은 합성수".format(n))

if __name__ == "__main__" :
    check_primenum(17)
    check_primenum(130)
    check_primenum(21)
    check_primenum(59)

=====<print>=====

17은 소수
130은 합성수
21은 합성수
59은 소수
```

### 4) 추가 코드
#### 여러개의 랜덤 숫자를 소수인지 합성수인지 확인하는 코드
```
def check_prime_num(mylist) :
    for i in mylist :
        num = int(i)
        checking_num(num)

def checking_num(n) :
    i = 2
    while i < n :
        if n % i == 0 :
            break
        i = i + 1
    if i == n :
        return print("{}은 소수".format(n))
    else :
        return print("{}은 합성수".format(n))


import random

random_list = [random.randint(1, 999) for _ in range(10)]
print(random_list)

=====<print>=====

[304, 857, 910, 401, 392, 20, 53, 174, 495, 235]

```
```
check_prime_num(random_list)

=====<print>=====

304은 합성수
857은 소수
910은 합성수
401은 소수
392은 합성수
20은 합성수
53은 소수
174은 합성수
495은 합성수
235은 합성수
```

# 009. 2 ~ N 사이의 모든 소수를 추출하기

### 1) 접근풀이 및 조건
- 앞에서 다룬 소수 확인 코드를 기반으로 2~N 까지의 반복문을 적용한다.
- 2~N 까지의 반복문에서 소수 확인 코드를 호출하는 방식으로 구현할 수 있다.

### 2) 코드

#### 조건1 : 2~N 까지의 반복문
- 반복문에 소수를 확인하는 함수를 호출하도록 한다.

```
i = 2
n = 10
while i <= n :
    print(i)
    #check_prime(n)
    i = i + 1

=====<print>=====

2
3
4
5
6
7
8
9
10
```

### 3) 최종 코드
```
def solve_2_to_n(N) :
    i = 2
    while i <= N :
        check_prime(i)
        i = i + 1
        
def check_prime(n) :
    i = 2
    while i < n :
        if n % i == 0 :
            break
        i = i + 1
    if i == n : 
        print("{0} 은 소수".format(n))
    else :
        print("{0} 은 합성수".format(n))

solve_2_to_n(10)

=====<print>=====

2 은 소수
3 은 소수
4 은 합성수
5 은 소수
6 은 합성수
7 은 소수
8 은 합성수
9 은 합성수
10 은 합성수
```

#### 소수만 출력
- 모든 return 값을 num 이라는 새로운 리스트에 저장한다.
- 소수가 아닌 것은 Nonetype 으로 저장 되기 때문에, 소수가 아닌 수는 0 으로 저장한다.
- 전체 수에 대한 소수 확인 끝난 후 반복문에서 num 리스트의 수를 하나씩 꺼내어 0 이 아닌 것만 print 한다.
```
def find_prime_num(n) :
    num = []
    i = 2
    while i <= n :
        x = checking_num(i)
        num.append(x)
        i = i + 1

    print("< {} ~ {} 사이의 소수 >".format(2, n))

    for t in range(len(num)) :
        if num[t] != 0 :
            print(num[t], end=" ")

def checking_num(N) :
    j = 2
    while j < N :
        if N % j == 0 :
            break
        j = j + 1
    if j == N :
        return N
    else :
        return 0

find_prime_num(20)

=====<print>=====

< 2 ~ 20 사이의 소수 >
2 3 5 7 11 13 17 19
```

# 010. 약수구하기

### 1) 접근풀이 및 조건
- 약수란 어떤 수를 나누어 떨어지게 하는 수를 말한다. (8 의 약수는 1,2,4,8)
- 2~N 까지의 숫자가 소수이면 "소수"를 출력하고, 소수가 아니면 해당 숫자의 약수를 출력
- 약수를 구하는 방식은 소수를 구하는 방식과 비슷하지만, 숫자가 클 경우 계산량이 커지게 된다. 따라서 다른 방법을 사용한다.
    - 약수중 가장 큰 숫자는 해당 숫자의 제곱근보다 작다는 정의를 사용하면 계산량을 줄일 수 있다.
- 조건 :
    - n 의 약수를 구하기 위해서 2~n의 제곱근까지만 탐색한다.
    - 소수가 아닌 경우에는 약수를 구해야 하기 때문에 이전의 소수를 구하는 문제와는 달리 break 문을 사용할 수 없다.
    - 소수인지 아닌지를 저장해 두기 위해 플래그 변수를 사용한다.

### 2) 코드

#### 조건1 : n 의 약수를 구하기 위해 2~n 사이의 제곱근까지만 탐색
- 제곱근을 구하기 위해 sqrt() 함수를 사용할 수 있다. 하지만 반복문을 통과할 때마다 함수를 호출해야 하므로 비효율적이다.
```
from math import sqrt

i = 2
n = 100
while i <= sqrt(n) :
    print(i)
    i = i + 1

=====<print>=====

2
3
4
5
6
7
8
9
10
```
```
print(sqrt(100))

=====<print>=====

100
```
#### 다른 방법으로는 반복문의 제어 조건으로 ixi <= n 을 사용하면 함수의 호출 없으므로 성능이 더 낫다.
```
i = 2
n = 100
while i * i <= n :
    print(i)
    i = i + 1

=====<print>=====

2
3
4
5
6
7
8
9
10
```
#### 조건2 : break 문 없이 소수와 약수를 구한다.
- 해당 숫자가 소수가 아닌경우 flag 변수를 False 값으로 저장하고, 이 flag 값을 main 함수에서 isPrime() 함수의 매개변수로 넘기는 숫자가 소수인지 아닌지를 확인하는 용도로 쓸 수 있다.
```
# 소수를 확인하는 함수
def isPrime(k) :
    global flag
    i = 2
    while i * i <= k :
        if k % i == 0 :
            flag = False
        i = i + 1
    return flag

# 약수를 확인하는 함수
def isnonPrime(k) :
    i = 1
    while i <= k :
        if k % i == 0 :
            print(i, end=" ")
        i = i + 1

if __name__ == "__main__" :
    j = 2
    while j <= 20 :
        flag = True   ### flag 를 다시 True 로 설정해 주어야 한다. isPrime() 함수에는 flag 를 True 로 바꾸어주는 코드가 없기때문이다.
        if isPrime(j) == True :
            print("{0} : 소수".format(j))
        else :
            print("{0} : 합성수, 약수 :".format(j))
            isnonPrime(j)
            print("\n")
        j = j + 1


=====<print>=====

2 : 소수
3 : 소수
4 : 합성수, 약수 :
1 2 4

5 : 소수
6 : 합성수, 약수 :
1 2 3 6

7 : 소수
8 : 합성수, 약수 :
1 2 4 8

9 : 합성수, 약수 :
1 3 9

10 : 합성수, 약수 :
1 2 5 10

11 : 소수
12 : 합성수, 약수 :
1 2 3 4 6 12

13 : 소수
14 : 합성수, 약수 :
1 2 7 14

15 : 합성수, 약수 :
1 3 5 15

16 : 합성수, 약수 :
1 2 4 8 16

17 : 소수
18 : 합성수, 약수 :
1 2 3 6 9 18

19 : 소수
20 : 합성수, 약수 :
1 2 4 5 10 20
```
#### 2~n 사이의 숫자중 소수와 합성수를 확인 하고, 합성수이면 약수를 출력
- up_num 에서 먼저 isPrime() 을 호출하여 소수인지를 확인한다.
- 소수이면 return True, 합성수이면 return False 이다.
    - isPrime() 함수에서 flag 변수의 값을 return 으로 반환해준다. 
- 이것을 조건문으로 사용하여 True 이면 소수를 출력하고, False 이면 합성수라는 문구를 출력한다. 
    - isnonPrime() 함수에서 약수를 num 리스트에 담아 return 으로 반환해준다.
```
# 숫자를 증가시키는 함수
def up_num(n) :
    i = 2
    while i <= n :
        isPrime(i)
        if isPrime(i) == True :
            print("{} 는 소수".format(i))
        else :
            print("{} 는 합성수, {} 의 약수 :".format(i, i), isnonPrime(i))
        i = i + 1

# 소수인지 확인하는 함수
def isPrime(k) :
    flag = True
    i = 2
    while (i*i) <= k :
        if k % i == 0 :
            flag = False
        i = i + 1
    return flag

# 소수가 아닌 합성수인 경우 약수를 확인하는 함수
def isnonPrime(k) :
    num = []
    i = 1
    while i <= k :
        if k % i == 0 :
            num.append(i)
        i = i + 1
    return num
```
- 함수 호출
```
up_num(20)

=====<print>=====

2 는 소수
3 는 소수
4 는 합성수, 4 의 약수 : [1, 2, 4]
5 는 소수
6 는 합성수, 6 의 약수 : [1, 2, 3, 6]
7 는 소수
8 는 합성수, 8 의 약수 : [1, 2, 4, 8]
9 는 합성수, 9 의 약수 : [1, 3, 9]
10 는 합성수, 10 의 약수 : [1, 2, 5, 10]
11 는 소수
12 는 합성수, 12 의 약수 : [1, 2, 3, 4, 6, 12]
13 는 소수
14 는 합성수, 14 의 약수 : [1, 2, 7, 14]
15 는 합성수, 15 의 약수 : [1, 3, 5, 15]
16 는 합성수, 16 의 약수 : [1, 2, 4, 8, 16]
17 는 소수
18 는 합성수, 18 의 약수 : [1, 2, 3, 6, 9, 18]
19 는 소수
20 는 합성수, 20 의 약수 : [1, 2, 4, 5, 10, 20]
```
