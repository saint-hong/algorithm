# 011. 소수 구하기 (에라토스테네스의 체)

### 1) 접근풀이 및 조건
- 에라토스테네스의 체 : 그리스의 수학자 에라토스테네스가 소수를 찾기위해 만든 방법이다. 어떤 물질을 체로 걸러서 필요한 것만 골라내듯이 소수를 찾는 방법을 의미한다. 
- 소수를 찾는 방법 : 에라토스테네스의 체는 자연수 중에서 소수 자신을 제외하고 소수의 배수를 제거하여 남은 수를 골라내는 방식이다.
    - 소수 : 2, 3, 5, 7, 11, 13 ...
    - 소수의 배수를 순차적으로 제거 : 2의 배수 제거, 3의 배수 제거, 5의 배수 제거 ... 
- 소수들의 배수를 제거하고 나면, 소수 자신만 남게 된다.
- 조건 :
    - 1은 소수가 아니므로 제외. 100 까지의 수중에서 2의 배수인 것을 제외한다.
    - 다음은 3의 배수인 것을 제외한다.
    - 다음은 5의 배수인 것을 제외한다. 이러한 식으로 소수들의 배수들을 차례로 제거한다.

### 2) 코드
- 리스트에서 특정한 것을 제외 혹은 제거하고 남은 것을 선택하고 싶을 때, 굳이 리스트에서 그 값을 삭제한다는 접근보다, 특정 값을 다른 값으로 변환 시키고, 변환되지 않은 값을 선택하면 훨씬 간편함.

#### 리스트에 공통적인 값을 채워 넣을 수 있다.

```
check = [True] * 10
check

=====<print>=====

[True, True, True, True, True, True, True, True, True, True]
```

- 리스트에 1 데이터 채워 넣기
```
t = 1

checked = [t] * 10
checked

=====<print>=====

[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
```
#### 특정값으로 채워진 리스트에서 특정 인덱스의 값만 변환할 수 있다.

```
checked[5] = 0
checked

=====<print>=====

[1, 1, 1, 1, 1, 0, 1, 1, 1, 1]
```
#### 리스트의 특정값을 채워넣고, 변환시키는 방법을 반복문과 조건문과 함께 사용하면, 특정한 값의 해당하는 것만 골라낼 수 있다.
- 앞에서 다룬 소수 확인 함수가 구조상 더 간단하지만, 에라토스테네스의 체의 방식은 많이 사용된다고 함
- 어떠한 것을 순차적으로 제외시키고 남은 것을 출력하는 방식

```
def find_Primenum(n) :
    checked = [True] * 1000          # checked 라는 변수에 True 값이 1000 개인 리스트를 저장
    i = 2                            # i 는 1 씩 증가하는 자연수, 첫번째 반복문의 제어변수
    k = 1                            # k 는 하위 반복문에서 사용할 변수이다. i 와 곱해지는 수
    while i < n :
        if checked[i] == True :      # checked 리스트가 True 인 것만 인쇄를 한다. 하위 반복문에서 특정값이 False 가 된다.
            print(i, end=" ")        # 소수만 출력
            j = 1                    # j 는 자연수 i의 배수를 저장하는 변수, 반복문의 제어변수
            while j < n :
                checked[j] = False   # j 는 i 의 배수 즉 합성수이므로 checked 리스트에서 해당하는 값을 False로 바꿔준다.
                k = k + 1            # k 가 1씩 증가하면서 i 와 곱해진다.
                j = i * k            # j 에 2 의 배수, 3의 배수, 4의 배수... 값이 저장되고 j 에 해당하는 checked 리스트가 False로 변환.
            k = 1                    # 자연수 i 의 배수가 끝나면, 증가한 k 를 다시 1로 변환시켜준다.
        i = i + 1
```
- 함수 호출
```
find_Primenum(100)

=====<print>=====

2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97
```

# 012. 약수의 합 출력하기

### 1) 접근풀이 및 조건
- 약수 구하기 코드를 사용하여 접근
- 조건 :
    - 주어진 숫자 n의 약수는 1과 자기 자신도 포함
    - 약수를 구할 때마다 변수에 더하여 합을 구한다.

### 2) 코드

#### 1과 자기자신을 포함한 숫자 n의 약수
- 반복문의 제어변수 i는 1부터 숫자 n과 같은 때까지 증가시켜야 n이 포함된다.

```
def f(n) :
    i = 1
    while i <= n :
        if n % i == 0 :
            print(i)
        i = i + 1
```
```
f(10)

=====<print>=====

1
2
5
10
```

#### 약수의 합은 특정 변수에 저장하여 더하는 방식으로 접근하면 간편하다.

```
def f2(n) :
    i = 1
    sum = 0
    while i <= n :
        if n % i == 0 :
            print(i)
            sum = sum + i
        i = i + 1
    return sum
```
```
f2(10)

=====<print>=====

1
2
5
10

18
```

### 3) 최종 코드

```
def final_solve(n) :
    i = 1
    ans = 0
    while i <= n :
        if n % i == 0 :
            ans = ans + i
            print(i)
        i = i + 1
    return ans
```
```
final_solve(100)

=====<print>=====

1
2
4
5
10
20
25
50
100

217
```

#### 추가 코드 : 2부터 20까지 수의 약수들의 총합

```
def func_1(n) :
    i = 2
    total_sum = 0
    while i <= n :
        print("{} 의 약수의 합 : {}".format(i,func_2(i)))
        total_sum = total_sum + func_2(i)
        i = i + 1
    print("\n")
    print("전체 약수의 합 : {}".format(total_sum))

def func_2(k) :
    j = 1
    ans = 0
    while j <= k :
        if k % j == 0 :
            ans = ans + j
        j = j + 1
    return ans
```
```
func_1(20)

=====<print>=====

2 의 약수의 합 : 3
3 의 약수의 합 : 4
4 의 약수의 합 : 7
5 의 약수의 합 : 6
6 의 약수의 합 : 12
7 의 약수의 합 : 8
8 의 약수의 합 : 15
9 의 약수의 합 : 13
10 의 약수의 합 : 18
11 의 약수의 합 : 12
12 의 약수의 합 : 28
13 의 약수의 합 : 14
14 의 약수의 합 : 24
15 의 약수의 합 : 24
16 의 약수의 합 : 31
17 의 약수의 합 : 18
18 의 약수의 합 : 39
19 의 약수의 합 : 20
20 의 약수의 합 : 42


전체 약수의 합 : 338
```
# 013. 반복문을 사용하여 최대공약수 구하기

### 1) 접근풀이 및 조건
- 최대공약수 : 어떤 두 수의 공통된 약수중에서 가장 큰 약수
- 최대공약수를 구하는 방법 :
    - 소인수 분해 : 숫자 a와 b를 각각 소인수분해 한 후 공통된 인수를 찾는다.
        - 192 : 2*2*2*2*2*2*3 = 2^6*3 , 72 : 2*2*2*2*3*3 = 2^3*3^2 , 두 수의 최대공약수는 2^3*3 = 24 이다.
    - 유클리드 호제법 : 숫자 a와 b 중 큰 숫자로 다른 숫자를 나눈 값의 나머지를 구한다. 이 나머지와 원래 두 수중 작은 수의 크기를 비교하여 큰 수로 다시 나눈 후 나머지를 구한다. 이 과정을 나머지가 0이 나올 떄까지 반복한다. 나머지가 0이 나온 계산의 나눈 수가 최대공약수이다.
        - 192 % 72 = 48 , 72 % 48 = 24 , 48 % 24 = 0 , 따라서 24가 두 수의 최대공약수이다.
- 알고리즘으로 구현할 때는 소인수분해보다 유클리드호제법이 더 간단하다.
- 조건 :
     - 2개의 수 a와 b에서 큰 수를 a라하고, 작은 수를 b라고 했을 때 a%b가 0이 될때까지 반복한다.

### 2) 코드
#### 조건1 : 큰 수 a, 작은 수 b라고 정의. a%b = 0 이 될때까지 반복

```
def f(a, b) :         # a가 b보다 크다고 가정 
    while b > 0 :     # b는 나머지를 저장하는 변수가 되고, 반복문의 제어변수로 0보다 같거나 작아지면 반복문 중지
        c = b         # 변수 c에 b의 값을 저장한다. 제어변수인 b에 나머지 값을 저장하기 위해서
        b = a % b     # 변수 b에 a를 b로 나눈 나머지 값을 저장, 원래 b의 값은 c에 저장됨
        a = c         # a를 b로 나눈 나머지를 구한 후 변수 a에 b의 값을 저장, 이 과정을 통해서 큰 수로 작은 수를 나누는 방법이 반복됨
    return a
```
```
f(192, 72)

=====<print>=====

24
```

### 3) 최종 코드
- 함수호출시 입력받은 아규먼트를 비교하여 큰 수를 a, 작은 수를 b에 저장
- counter 변수를 추가하고 반복문을 통과할 때마다 1씩 증가. a와 b를 몇번 나누었는지 횟수를 알 수 있다.
- 나머지값을 구한 코드 아래에 print 문을 넣어 큰수, 작은수, 나머지가 어떻게 변하는지 확인 할 수 있다.
- 새로운 변수 c를 사용하여 간단한 코드로 반복적으로 연결된 수행을 간단한 코드로 만들 수 있다.

```
def gcd(p, q) :
    counter = 0
    if p < q :
        a = p
        b = q
    else :
        a = q
        b = p
    while b > 0 :
        counter += 1
        c = b
        b = a % b
        print("큰수 : {0}, 작은수 : {1}, 나머지 : {2}".format(a, c, b))
        a = c
    return print("\n","{0} 과 {1} 의 최대공약수 : {2}".format(p, q, a), ", ","계산 횟수 : ", counter)
```
```
gcd(24, 80), counter

=====<print>=====

큰수 : 24, 작은수 : 80, 나머지 : 24
큰수 : 80, 작은수 : 24, 나머지 : 8
큰수 : 24, 작은수 : 8, 나머지 : 0

 24 과 80 의 최대공약수 : 8 ,  계산 횟수 :  3
(None, 12)
```
```
gcd(1987628, 8372), counter

=====<print>=====

큰수 : 8372, 작은수 : 1987628, 나머지 : 8372
큰수 : 1987628, 작은수 : 8372, 나머지 : 3464
큰수 : 8372, 작은수 : 3464, 나머지 : 1444
큰수 : 3464, 작은수 : 1444, 나머지 : 576
큰수 : 1444, 작은수 : 576, 나머지 : 292
큰수 : 576, 작은수 : 292, 나머지 : 284
큰수 : 292, 작은수 : 284, 나머지 : 8
큰수 : 284, 작은수 : 8, 나머지 : 4
큰수 : 8, 작은수 : 4, 나머지 : 0

 1987628 과 8372 의 최대공약수 : 4 ,  계산 횟수 :  9
(None, 12)
```
# 014. 재귀호출을 사용하여 최대공약수 구하기

### 1) 접근풀이 및 조건
- 최대공약수를 구하는 방법인 유클리드 호제법을 재귀호출을 사용하여 구현
- 재귀호출을 사용하면 코드가 간단해진다.
- 조건 :
    - 반복문 대신 재귀호출을 사용한다.
    - 재귀 호출의 종료조건은 작은수가 0이 될때 종료한다.

### 2) 코드
#### 조건1 : 반복문 대신 재귀호출을 사용
- 앞의 문제에서 만든 유클리드 호제법의 예, 여기에서 재귀호출의 힌트를 얻을 수 있다.
- a = c = b , b = a % b

```
# while b > 0 :
#    c = b
#    b = a % b
#    a = c
```

#### 재귀 호출 시 a 의 아규먼트가 b 가 되고, b 의 아규먼트가 a % b 가 된다.
- 여기에 재귀호출의 종료 조건을 추가해주면 된다

```
def f(a, b) :
    f(b, a % b)
```

### 3) 최종코드

```
def solve_recursive(p, q) :
    if q == 0 :
        return p
    print(p, q, p % q)
    return solve_recursive(q, p % q)
```
```
solve_recursive(24, 64)

=====<print>=====

24 64 24
64 24 16
24 16 8
16 8 0
8
```
```
import random

if __name__ == "__main__" :
    a = int(random.randint(1, 100))
    b = int(random.randint(1, 100))
    result = solve_recursive(a, b)
    print("{} 와 {} 의 최대공약수 : {}".format(a, b, result))

=====<print>=====

14 86 14
86 14 2
14 2 0
14 와 86 의 최대공약수 : 2
```
# 015. 소인수분해 구하기 (무한루프 사용)
### 1) 접근풀이 및 조건
- 소인수분해 : 합성수를 소수의 곱으로 나타내는 방법 
    - 24 = 2 * 2 * 2 * 3 = $2^3 * 3$
- 조건 :
    - 주어진 숫자 n이 i로 나누어지면 떨어지면 i는 n의 인수이다. n에 n을 i로 나눈 몫을 저장하여 이과정을 반복한다.
        - 몫을 다시 i로 나누고, 나누어 떨어지지 않을때까지 반복한다. (2로 반복하여 나누다가 나누어지지 않으면 3으로 나눈다)
    - 반복문을 간단하게 하기 위해 무한루프를 사용한다.
        - 항상 참인 1 이나 True 를 반복문에 사용
        - 무한루프를 빠져나오는 코드도 함께 작성해 주어야 함

### 2) 코드
#### 조건1 : 주어진 숫자 n이 i로 나누어지면 i는 n의 인수이며, n = n // i 를 저장하여 이 과정을 반복한다.
```
if n % i == 0 :    # n의 인수를 찾는 조건
    print(i)
    n = n // i     # n을 i로 나눈 몫을 저장
```
```
while 1 :              # 무한루프를 설정
    if n % i == 0 :
        print(i)
        n = n // i
    else :             # n이 i로 나누어지지 않으면 무한루프를 중단
        break
    i = i + 1          # 무한루프를 빠져나오면 i = i + 1 실행 후 다시 무한루프 시작
```

### 3) 최종코드
- i가 2부터 n까지 증가하는 코드를 추가
```
def calc_prime_factorization(n) :
    i = 2
    while i <= n :
        while 1 :
            if n % i == 0 :
                print(i, end=" ")
                n = n // i
            else :
                break
        i = i + 1
```
```
if __name__ == "__main__" :
    calc_prime_factorization(48)

=====<print>=====

2 2 2 2 3
```

### 4) while 반복문 사용
- continue, break

#### i를 증가시켜서 0부터 4까지 출력
```
i = 0
while i < 5 :
    print(i)
    i = i + 1

=====<print>=====

0
1
2
3
4
```

#### 무한루프를 빠져나오는 break 조건문 사용
- i가 1씩 증가할때마다 i를 출력하고, if문의 조건에 해당되지 않으면 무한루프가 계속 실행된다. if문의 조건에 해당되면 break 멈춘다. 
```
i = 1
while 1 :
    print(i)
    i += 1
    if i >= 5 :
        break

=====<print>=====

1
2
3
4
```
#### continue를 사용하면 while 문이 실행되는 도중에 조건문으로 돌아갈 수 있다.

```
i = 0
while i < 11 :       # 조건문
    i += 1
    if i % 2 != 0 :  # 홀수이면 continue, 짝수이면 print() 실행
        continue     # 조건문으로 돌아간다. if문을 통과하지 못하면 조건문에서 빠져나와 출력
    print(i)

=====<print>=====

2
4
6
8
10
```
#### while 조건문에 1이나 True와 같은 항상 참인 값을 넣어주면 무한루프가 된다.

```
i = 0
while 1 :
    i = i + 1
    print(i)
    if i > 10 :
        break

=====<print>=====

1
2
3
4
5
6
7
8
9
10
11
```

### 5) 소인수와 지수의 곱으로 출력해주는 코드
```
def prim_factorization(n) :
    # 최초 숫자을 다른 변수에 저장 : transform 함수로 넘겨주기 위함
    x = n
    
    # 소인수와 소인수의 횟수를 저장하는 배열을 2개 만든다.
    i_array = [0] * 1000
    i_count_array = [0] * 1000
    
    # 소인수 변수 i, 배열에 저장할 때 인덱스로 사용할 변수 start_i
    i = 2
    start_i = 0
    
    # 소인수 찾는 코드
    while i <= n :
        i_counter = 0
        while 1 :
            if n % i == 0 :
                i_counter += 1
                n = n // i 
            else:
                break
        
        # 소인수와 소인수의 횟수를 배열에 저장하는 코드
        # 소인수의 횟수가 0일 경우 배열에 저장하지 않는 조건 추가
        if i_counter != 0 :
            i_array[start_i] = i
            i_count_array[start_i] = i_counter
        

        # 소인수 증가, 소인수 횟수 증가
        i = i + 1
        start_i = start_i + 1
        
        #print(i_array, i_count_array)
        
    # 함수 호출    
    return transform_pf(i_array, i_count_array, x)

# 배열에 저장한 인수와 지수를 곱의 형태로 변환해주는 코드
def transform_pf(array1, array2, N) :
    
    # array 에서 모든 0 을 제거
    while 0 in array1 :
        array1.remove(0)
    while 0 in array2 :
        array2.remove(0)
    
    print("< {} 의 소인수분해 >".format(N))
    
    # 새로운 리스트를 만든 후 소인수와 지수의 곱으로 표현한 후 저장
    new_lst = []
    for j in range(len(array1)) :
        new_lst.append(str(array1[j]) + "**" + str(array2[j]))
    
    # join 함수를 사용하여 new_lst 의 요소들을 연결에서 출력
    print(" x ".join(new_lst))
```

- 함수 호출
```
prim_factorization(387)

=====<print>=====

< 387 의 소인수분해 >
3**2 x 43**1
```

# 016. 최소공배수 구하기

### 1) 접근풀이 및 조건
- 최소공배수 : 두 개의 숫자의 배수 중에서 가장 작은 숫자
- 최소공배수 구하는 방식 :
    - 각각의 숫자를 소인수분해 한 뒤 소인수들 중에서 지수가 가장 큰 수를 찾아서 곱한다.
        - $192 = 2^6 * 3 , \;\;  72 = 2^3 * 3^2$ 일 경우 최소공배수는 $26 * 32 = 576$
    - 또는 어떤 숫자를 두 개의 숫자로 나누어서 공통으로 떨어지는 첫 번째 수를 찾는다.
- 코드 구현은 두 번째 방법이 간편하다.
- 조건 :
    - 반복문을 사용하여 2개의 숫자가 모두 나눠질 수 있는 첫 번쨰 나오는 수를 구한다.
    - 반복문의 끝을 어떤 수로 설정할지 고민 필요.

### 2) 코드

#### 조건 1 : 반복문을 사용하여 2개의 숫자가 모두 나눠질 수 있는 첫 번째 숫자를 찾는다.

```
def f(a, b) :
    i = 2
    while i < 1000 :
        if i % a == 0 and i % b == 0 :
            break
        i = i + 1
    print(i)
```
```
f(192, 72)

=====<print>=====

576
```
#### while 문의 제어문으로 1을 두면 두 수의 최소공배수가 처음 나올 때까지 i 를 증가시킨다

```
def f(a, b) :
    i = 2
    while 1 :
        if (i % a == 0) and (i % b == 0) :
            break
        i = i + 1
    print(i)
```
```
f(62, 73)

=====<print>=====

4526
```

#### 조건 2 : 반복문의 끝 설정
- 두개의 숫자가 커지면 반복문의 제어변수에 들어갈 범위도 커지게 된다. 어떤 수로 정하면 반복문을 효율적으로 실행할 수 있을까.
- 두 수의 곱에 해당하는 숫자를 범위로 설정하면 최소공배수를 찾는데 효율적이다.
- 항상 그런 것은 아님
- 3, 8의 최소공배수의 경우 두 수의 곱이 최소공배수인 경우이므로, 제어문의 범위로 (a*b)*10 해주면 좋을 것 같다.

```
def f(a, b) :
    counter = 0
    i = 2
    while i < (a * b) * 10 :
        if (i % a == 0) and (i % b == 0) :
            counter += 1    # counter 변수를 if 문을 통과할 떄마다 1 증가하여, 조건문을 설정하면 원하는 갯수만 출력할 수 있다.
            print(i)
            if counter == 3 :   # a, b 의 공배수를 3개까지 출력
                break
        i = i + 1
```
```
f(192, 72)

=====<print>=====

576
1152
1728
```
```
f(3, 8)

=====<print>=====

24
48
72
```
#### return 으로 삼항연산자를 사용하는 예

```
def f(a, b) :
    if a > b :
        return 1
    else :
        return 0
```
```
f(1, 2)

=====<print>=====

0
```
```
def f(a, b) :
    return 1 if a > b  else 0
```
```
f(15, 2)

=====<print>=====

1
```
### 3) 최종코드

```
def calc_LCM(n) :
    a = 2
    b = 3
    c = 5
    i = 2
    
    while i < n :
        if (i % a == 0) and (i % b == 0) and (i % c == 0) :
            break
        i = i + 1
    print("2,3,5 의 최소공배수 : ", i)
```
```
calc_LCM(100)

=====<print>=====

2,3,5 의 최소공배수 :  30
```

### 4) 함수 사용 예
- 매개변수와 리턴값은 있어도 되고 없어도 된다. 출력 방식이 달라진다.

```
# 매개변수가 없는 함수

def say() :
    return "Hello"

a = say()
print("매개변수가 없는 함수")
print(a)

=====<print>=====

매개변수가 없는 함수
Hello
```
```
# 매개변수가 여러 개인 경우

def say(say1, say2) :
    print(str(say1) + ' ' + str(say2))

print("매개변수가 여러개인 경우")
say("one", 43)

=====<print>=====

매개변수가 여러개인 경우
one 43
```
```
# 리턴 값이 없는 함수
def say() :
    print("hello")

print("리턴 값이 없는 함수")
say()

=====<print>=====

리턴 값이 없는 함수
hello
```
```
# 리턴값이 여러개인 함수

def say(say1, say2) :
    return (say1, say2)

a = say("one", "two")
print("리턴값이 여러개인 함수")
print(a)
print(a[0], a[1])

=====<print>=====

리턴값이 여러개인 함수
('one', 'two')
one two
```
```
# 매개 변수가 몇 개인지 모를 경우

def ff(say1, say2, *args) :
    print("==== 매개변수 ====")
    print(say1 + ", " + say2)

    print("\n")

    print("==== args 로 받은 매개변수들 ====")

    for i in args :
        print(i)

print("# 매개 변수가 몇 개인지 모를 경우")
ff("one", "two", "three", 4, 5)

=====<print>=====

# 매개 변수가 몇 개인지 모를 경우
==== 매개변수 ====
one, two


==== args 로 받은 매개변수들 ====
three
4
5
```
# 017. 배열 채우기 (1)
- 현재 인덱스의 값을 이전 인덱스들을 연산하여 채운 배열을 만들고 출력하기

### 1) 접근풀이 및 조건
- 여러 프로그래밍 언어는 배열이라는 자료구조를 기본적으로 제공한다.
- 배열의 장점은 인덱스 처리에 있다. 즉 배열의 인덱스를 사용하여 여러가지 응용이 가능함.
- 조건 :
    - 배열을 사용할 때 인덱스 + 1 개의 배열을 사용해야 한다. 배열의 인덱스가 0 부터 시작하기 때문.
    - 이전 2개의 항목을 더하여 현재 배열의 값으로 저장한다.

### 2) 코드

#### 조건 1 : 배열을 사용할 때 인덱스 + 1 개의 배열을 사용해야 한다. 배열의 인덱스가 0 부터 시작하기 때문.
- 반복문에서 인덱스의 5의 값을 출력하려면 배열의 갯수는 5보다 커야 한다.
- 배열상에서 인덱스 [5] 의 위치는 6번째 자리이기 때문. 0,1,2,3,4,5

```
a = [1] * 5   # 배열의 길이 : 5 이고 인덱스는 [0], [1], [2], [3], [4] 이므로 [5] 는 범위를 벗어나게 된다.

i = 0
while i <= 5 :   # [5] 는 배열 a 의 범위를 벗어난다.
    print(a[i])
    i = i + 1

=====<print>=====

1
1
1
1
1
---------------------------------------------------------------------------
IndexError                                Traceback (most recent call last)
<ipython-input-81-a54974bce402> in <module>
      3 i = 0
      4 while i <= 5 :
----> 5     print(a[i])
      6     i = i + 1

IndexError: list index out of range
```

#### 배열의 길이를 인덱스의 범위보다 넓게 해줘야 에러가 안난다.
```
a = [1] * 6   # 배열의 길이
i = 0
while i <= 5 :
    print(a[i])
    i = i + 1

=====<print>=====

1
1
1
1
1
1
```
#### 조건2 : 이전 2개의 항목을 더하여 현재 배열의 값으로 지정

```
a = [1] * 11
i = 3
while i <= 10 :
    a[i] = a[i-1] + a[i-2]   # a[i] 에 a[i-1] 과 a[i-2] 의 합을 저장한다.
    i = i + 1
a

=====<print>=====

[1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
```

### 4) 최종코드

```
a = [1] * 100

def calc_array(n) :
    a[1] = 1
    a[2] = 1

    i = 3
    while i <= n :
        a[i] = a[i-1] + a[i-2] + 1
        i = i + 1
```
```
if __name__ == "__main__" :
    calc_array(10)
    i = 0
    while i <= 11 :
        print(a[i])
        i = i + 1

=====<print>=====

1
1
1
3
5
9
15
25
41
67
109
1
```
#### 인덱스 확인하는 코드
- a.index(데이터 값)
- 타입은 int 로 출력 된다.

```
# 배열에서

a = [1,2,3,4]
a

=====<print>=====

[1, 2, 3, 4]
```
```
a.index(3), type(a.index(3))

=====<print>=====

(2, int)
```
```
# 문자열에서

b = "abc"
b

=====<print>=====

'abc'
```
```
b.index("b"), type(b.index("b"))

=====<print>=====

(1, int)
```

# 018. 배열 채우기 2

### 1) 접근풀이 및 조건
- 배열이 직접 인덱스를 계산하여 해당 인덱스에 값을 채워넣는 방법
- 조건 :
    - 배열 a를 1부터 100까지 액세스할 떄 a의 선언은 100 + 1로 해야한다.
    - 배열 a[0]의 초기값 설정을 해줘야 한다.

### 2) 코드
#### 조건1 : 배열의 인덱스 범위를 제어변수의 범위보다 크게 설정해주어야 한다.

```
a = [0] * 21
print(a)

i = 2 
while i <= 20 :
    a[i] = a[i//2] + 1
    i = i + 1

=====<print>=====

[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
```
```
print(a)

=====<print>=====

[0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4]
```
```
len(a)

=====<print>=====

21
```
#### 조건2 : a[0]의 설정
```
x = [0] * 21
def solve(n) :
    i = 2
    while i <= n :
        x[i] = x[i//2] + 2
        i = i + 1

def solve_2(m) :
    xx = [0] * 21
    i = 2
    while i <= m :
        xx[i] = xx[i//2] + 2
        i = i + 1
    return xx
```

#### 배열을 전역변수로 설정할 경우 함수를 호출할 떄마다 직전에 저장한 값에서 시작한다.
```
print(x)
solve(15)
print(x)

=====<print>=====

[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
[0, 0, 2, 2, 4, 4, 4, 4, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0]
```
```
solve(17)
print(x)

=====<print>=====

[0, 0, 2, 2, 4, 4, 4, 4, 6, 6, 6, 6, 6, 6, 6, 6, 8, 8, 0, 0, 0]
```

#### 배열을 함수안의 지역변수로 설정할 경우 함수를 호출할 때마다 배열이 초기화 된다.
```
solve_2(20)

=====<print>=====

[0, 0, 2, 2, 4, 4, 4, 4, 6, 6, 6, 6, 6, 6, 6, 6, 8, 8, 8, 8, 8]
```
```
solve_2(10)

=====<print>=====

[0, 0, 2, 2, 4, 4, 4, 4, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
```

### 3) 최종코드

```
aa = [0] * 101

def calc_array(n) :
    aa[1] = 1
    i = 2
    while i <= n :
        aa[i] = aa[i//2] + 1
        i = i + 1
```
```
if __name__ == "__main__" :
    calc_array(100)
    i = 0
    while i <= 100 :
        print(aa[i], end=" ")
        i = i + 1

=====<print>=====

0 1 2 2 3 3 3 3 4 4 4 4 4 4 4 4 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
```
# 019. 반복문을 사용하여 조합(nCr) 구하기

### 1) 접근풀이 및 조건
- nCr : n개 중에서 r개를 선택하는 경우의 수
    - <img src="https://latex.codecogs.com/gif.latex?nCr%20%3D%20%5Cdfrac%7Bn%21%7D%7Br%21%28n-r%29%21%7D%20%3D%20%5Cdfrac%7Bn*%28n-1%29%28n-2%29*...*%28n-r%29*%28%28n-r%29-1%29*%28%28n-r%29-2%29*...*2*1%7D%7Br*%28r-1%29*%28r-2%29*...*2*1*%28n-r%29*%28%28n-r%29-1%29*%28%28n-r%29-2%29*...*2*1%7D">
    - <img src="https://latex.codecogs.com/gif.latex?10C3%20%3D%20%5Cdfrac%7B10%21%7D%7B3%21%2810-3%29%21%7D%20%3D%20%5Cdfrac%7B10*9*8*%2810-3%29*%2810-3-1%29*%2810-3-2%29*...*2*1%7D%7B3*2*1*%2810-3%29*%2810-3-1%29*%2810-3-2%29*...*2*1%7D%3D%5Cdfrac%7B10*9*8%7D%7B3*2*1%7D%3D120">

### 2) 코드
- 순차적으로 곱셈하는 형태를 코드로 구현한 것
- <img src="https://latex.codecogs.com/gif.latex?%2810/1%29*%289/2%29*%288/3%29%3D%2810*9/2%29*%288/3%29%3D45*8/3">
```
def combi(n, r) :
    i = 1
    p = 1
    while i <= r :
        print(p, (n -i + 1), i)
        print("p = {} * {} // {} = {}".format(p, n-i+1, i, p * (n - i + 1) // i))
        print("\n")
        p = p * (n - i + 1) // i
        i = i + 1
    return p
```
```
# 10개 중에서 5개를 선택하는 경우의 수
combi(10, 5)

=====<print>=====

1 10 1
p = 1 * 10 // 1 = 10


10 9 2
p = 10 * 9 // 2 = 45


45 8 3
p = 45 * 8 // 3 = 120


120 7 4
p = 120 * 7 // 4 = 210


210 6 5
p = 210 * 6 // 5 = 252


252
```
```
def combi_2(n, r) :
    i = 1
    p = 1
    while i <= r :
        p = p * (n-i +1) // i
        i = i + 1
    return p
```
```
combi_2(10, 3)

=====<print>=====

120
```
# 020. 재귀호출을 사용하여 조합 구하기

### 1) 접근풀이 및 조건
- 재귀호출을 사용하기 위해 조합을 구하는 방법을 다르게 접근해 볼 수 있다.
- 3개의 공 중에서 2개의 공을 선택하는 경우의 수(3C2)는 마지막 공의 선택 여부를 기준으로 생각해 볼 수 있다.
    - 마지막 공을 선택하지 않고서 고르는 경우
    - 마지막 공을 선택하고서 고르는 경우
- 즉 3C2의 조합은 두 경우의 수를 합한 것과 같다.
- 조건 :
    - 마지막 공을 선택하지 않고서 고르는 경우 : 마지막 공을 제외한 나머지 공 2개 중에서 2개를 선택하는 문제가 된다. 즉 3C2 -> 2C2의 조합 문제가 된다.
    - 마지막 공을 선택하고서 고르는 경우 : 마지막 공을 하나 선택했기 때문에, 나머지 공 2개 중에서 1개를 선택하는 문제가 된다. 즉 3C2 -> 2C1의 조합 문제가 된다.
- nCr = f(n, r) = (마지막 공 선택하지 않는 경우) + (마지막 공 선택한 경우) = f(n-1, r) + f(n-1, r-1)

### 2) 코드

#### f(n, r) = f(n-1, r) + f(n-1, r-1) 을 재귀함수를 사용하여 간단하게 나타낼 수 있다.
```
def combi(n, r) :
    return combi(n-1, r) + combi(n-1, r-1)
```

#### r이 0이거나 n이 되면 재귀함수의 호출을 멈춘다.
- 제어문의 리턴값이 더해져 최종 값이 출력된다.

```
def combi_2(n, r) :
    if r == n or r == 0 :
        return 1
    else :
        return combi_2(n-1, r) + combi_2(n-1, r-1)
```
```
combi(3, 2)

=====<print>=====

3
```
#### 마지막 공 선택하지 않을 경우 : r = n 이므로 1 이 된다.
```
combi(2,2)

=====<print>=====

1
```

#### 마지막 공 선택한 경우 : (1,1) 의 경우와 (1,0) 의 경우의 합
- (1,1) 은 r = n 이므로 1
- (1,0) 은 r = 0 이므로 1

```
combi(2,1)

=====<print>=====

2

combi(1,1)

=====<print>=====

1

combi(1,0)

=====<print>=====

1
```
```
counter = 0

def combi_3(n, r) :
    global counter
    counter += 1
    print(counter)
    print("현재 n과 r : {}, {}".format(n, r))
    if r == n or r == 0 :
        return 1
    else :
        return combi_3(n-1, r) + combi_3(n-1, r-1)
```
```
combi_3(3,2)

=====<print>=====

1
현재 n과 r : 3, 2
2
현재 n과 r : 2, 2
3
현재 n과 r : 2, 1
4
현재 n과 r : 1, 1
5
현재 n과 r : 1, 0
3
```
