# 파이썬의 기본 구조와 기초 문법
- 파이썬은 최근 머신러닝, 웹 서비스, 빅 데이터와 같은 첨단 분야에서 강세를 보이는 언어
- 쉽고 다양한 플랫폼에서 활용 가능
- 활용도와 중요도가 매우 높은 언어

## 1. 파이썬의 이해

### 1-1. 파이썬의 장단점
- 그림 : 캔버스의 특징과 물감의 특징을 잘 알아야 한다.
- 프로그래밍 언어의 특징 이해와 나에게 맞는 개발 환경 구성
- 대표적인 프로그래밍 언어 : C, C++, Java
    - 강력하고 뛰어난 성능
    - 배우기 까다로움
- python의 장점
    - 빠른 학습속도
    - 대화형 쉘, 명령의 실행 결과를 빠르게 확인 할 수 있음
    - 확장기능 지원
    - 다양한 플랫폼에서 사용 가능 : 윈도우, 맥os, 리눅스 등
- python의 단점
    - c, c++에 비해서 수행 속도가 느리다. : 컴퓨터 파워가 높아져 격차가 줄어듦
    - 성능에 영향을 미치는 부분은 C언어 등으로 모듈화 가능 해졌다.
- 대학, 여러기관, 빅데이터 분석, 머신러닝, 딥러닝, 사물인터넷 분야에서 활용율 늘어남.

### 1-2. 파이썬의 역사
- 1980년 말 고안 -> 1991.2.20 귀도 반 로썬이 발표한 플랫폼
    - 독립적
    - 인터프리터 방식
    - 객체지향적
    - 동적
    - 대화형 성격을 가진 프로그래밍 언어
- "Monty Pythons Flying Circus" 코미디 프로그램의 제목에서 영감을 얻음
    - Python 비단뱀

### 1-3. 파이썬의 종류
- **Cpython : C로 작성된 파이썬 : 일반적인 파이썬을 가리킴 : 표준 파이썬**
- IronPython : .Net과 Mono용, C#으로 구현됨
- Jython : 자바로 구현된 파이썬, 자바가상머신에서 동작함, 자바클래스, 자바표준라이브러리 사용 가능
- PyPy : 파이썬으로 구현된 파이썬, C파이썬보다 빠르다.

### 1-4. 파이썬의 특징
- 파이썬 개발의 목표와 철학
    - 아름다운 것이 추한 것보다 낫다
    - 명시적인 것이 묵시적인 것보다 낫다
    - 단순한 것이 복잡한 것보다 낫다
    - 복잡한 것이 난해한 것보다 낫다
    - 가독성이 중요하다. 
- 파이썬 특징
- 인터프리팅 방식 : 실행 시간에 명령을 해석해서 실행함
    - 명령의 실행결과를 대화형으로 바로 확인 할 수 있다.
- 동적타이핑 dynamic typing
    - 실행 시간 값에 의해 자료형이 결정 됨
- Garbage Collecor
    - 생성된 객체에 대한 메모리 관리
- 가독성
    - 코드블록의 들여쓰기 구조로 이루어져 있다.
    - 읽기 쉬운 구조로 작성하게 된다.
- 풍부한 라이브러리 
    - 라이브러리 환경이 활발함
    - 바로 사용가능한 표준 라이브러리와 통합환경이 배포판과 함께 제공된다.
    - 정규표현식, 운영체제의 시스템 호출, XML 처리, 직렬화, 각종 통신프로토콜,
    - 전자메일이나 csv파일 처리, 데이터베이스 접속, 그래픽 사용자 인터페이스,
    - HTML이나 파이썬 코드 구문 분석 도구 등
- 유니코드
    - 문자열
- 오픈소스
    - 파이썬 소프트웨어 재단에서 관리
    - 무료
- 다양한 프로그래밍 패러다임 지원
    - 객체지향, 함수형 프로그래밍 지원
- 학습 용이성
    - 프로그램의 문서화 도 언어의 기본 기능에 포함된다.
    - 도움말 문서와 API도 체계적으로 정리되어 있다. 
        - API : application programming interface : 운영체제가 제공하는 함수의 집합
    - 읽기 쉬움, 효율적인 코드를 간단하게 쓰려는 철학이 반영 됨.
- 내장 스크립트 언어
    - 다른 언어로 쓰인 모듈을 연결할 때 이용됨
    - 많은 상용 프로그램에 내장되어 스크립트 언어로 활용 됨

### 1-5. 파이썬 버전
- 파이썬 2.0 : 2000년 10월 16일 배포
    - garbage collector(쓰레기수집기)와 유니코드 지원
    - 개발과정에서의 투명한 공동체 지원 : 파이썬 재단
- 파이썬 3.0 : 2008년 12월 3일 배포    
    - 2.대 버전과 하위호환성 x
    - 주요기능 다수가 이전 버전과 호환되도록 파이썬 2.6, 2.7에 반영
- "파이썬 2.x는 레거시, 파이썬 3.x가 파이썬의 현재와 미래"
- 2.x와 3.x의 차이
    - 내장자료형의 내부적인 변화
    - 일부 자료형의 구성요소 제거
    - 표준라이브러리 패키지 재배치
    - 향상된 유니코드 지원 : 모든 유니코드를 문자열 처럼 사용
    - 한글 변수 사용 가능
    - print -> print()로 변화

### 1-6. 유니코드
- 대표코드 : 유니코드와 아스키 코드 ascii
- 유니코드 : 16비트
    - 각 나라별 언어를 모두 표현하기 위해 만든 통합 코드체계
    - 65,536자 표현 가능
    - 16진수 값으로 4비트 표현 가능
    - 한글 : 초성 19자, 중성 21자, 종성 28자 조합 : 11,172자
- 아스키코드 : 7비트
- 파이썬과 유니코드 

### 1-7. 파이썬의 활용
- 파이썬의 활용영역이 넓어짐
    - 빅데이터, 모바일, 사물인터넷 IoT, 인공지능 분야 등

### 1-8. 파이썬의 인기분야
- 웹 애플리케이션 개발 분야 : 장고, 플라스크 프레임워크
    - 장고 : 회원가입, 사용자 인증 등 공통기능 제공 django
    - 플라스크 : 간단한 웹서비스 또는 모바일 서버 구축에 적합 flask
- 데이터 수집 분야
    - 뷰티풀숩 : beautifulsoup : 웹크롤링 라이브러리, 문서수집, HTML 구문 분석, DOM 트리 탐색, 문서 분석 정보 추출 기능
    - 스크래피 : scrapy : 웹크롤링 프레임워크, 웹문서에서 데이터 추출 규칙 작성을 하면 문서 수집, 필요 데이터를 자동으로 추출해준다.
- 데이터 과학 및 인공지능 분야
    - numpy : 다차원배열 객체, 선형대수, 푸리에 변환, 난수 생성 기능 
    - pandas : 데이터 분석시 사용하는 표준라이브러리, 데이터 구조, 다양한 분석 도구 제공
    - scipy : 수학, 과학, 엔지니어링 등에 사용되는 패키지, 넘파이, 판다스, 심파이, 맷플롯립, 아이파이썬 등을 포함
    - scikit-learn : 데이터 마이닝, 데이터 분석을 위한 도구, 분류, 회귀, 군집, 차원축소와 같은 머신러닝을 지원하는 도구
    - tensorflow : 구글이 공개한 머신러닝 및 딥러닝 프레임워크, GPU를 이용한 연산지원, 각종 신경망 모델을 쉽게 구현
    - pytorch : 머신러닝 및 딥러닝 프레임워크, GPU를 이용한 연산지원, 간결한 코드, 신경망 모델을 쉽게 구현하도록 지원, 빠른 모델훈련시간, 실시간 결과값 시각화
- 파이썬 설치 후 코드 실행 : 윈도우 기준
    - IDLE에서 코드 실행
    - 명령프롬프트에서 코드 실행
    
## 2. 개발환경과 코드작성
- 통합개발환경 IDE : Integrated Development Environment
    - 코딩을 위한 코드 편집기, 컴파일을 위한 컴파일러(또는 인터프리터), 디버깅을 위한 디버거 등 프로그램 개발에 필요한 도구들이 하나의 프로그램 개발 환경으로 통합되어 개발 생산성을 높이는 소프트웨어
- 파이썬 개발 지원 오픈소스 IDE
    - 파이참
    - visual studio code : 마이크로 소프트
    - pydev
- 디버깅 : 컴퓨터 프로그램의 정확성이나 논리적인 오류(버그)를 찾아내는 테스트 과정으로 효과적으로 수행하기 위해서는 자동화된 디버거 소프트웨어가 필요함
    - 중단점 지정 -> 프로그램 실행정지 -> 메모리에 저장된 값을 확인 -> 실행 재게, 코드실행 순서로 진행 된다.

### 2-1. 파이참
- 파이참 설치 방법

### 2-2. 비주얼스튜디오코드
- vscode 설치 방법

### 2-3. 파이썬 코드 작성법
- 들여쓰기
    - 잘못 된 들여쓰기로 치명적인 버그 발생할 수 있음
    - 4개 공백으로 들여쓰기
- 소스코드 인코딩
    - #
    - -*-
    - 한 행에 여러문장 기술시 ; 사용
- 파일과 모듈
    - 라이브러리 기능
    - 프로그램의 진입점 역할 기능
    - 두 기능이 다 있으면 if문으로 분기 해주어야 함. 
    - if __name__ == "__main__" :  소스코드가 메인으로 실행된 경우
    - 모듈을 만들면 재사용할 때 도움이 된다.

## 3. 기초 문법의 이해
- 프로그래밍 언어의 자료형의 타입들
    - 정수, 부동소수점, 문자열

### 3-1. 숫자형의 특징
- `리터럴 Literal` : 소스코드 상에서 내장 자료형의 상수값을 나타내는 용어
- 다양한 형태의 리터럴이 있다.
    - 15 : 정수형 리터럴 : <class "int">
    - 3.134 : 부동소수점 숫자형 리터럴 : <class "float"> 
    - "파이썬" : 문자열 리터럴 : <class "str">
    - True : 불리언 리터럴 : <class "bool">
    - [1, 2, 3] : 리스트형 리터럴 : <class "list">
    - 리터럴을 이용해 변수 초기화, 연산
- type() 함수 : 자료형 확인 : 값에 의해 자료형이 결정되는 동적 타이핑 언어인 경우 자료형을 확인 해야할 때가 있다.

### 3-2. 숫자형
- 파이썬의 숫자형 : 정수형, 부동소수점형, 허수형
    - 정수형 : 5
    - 부동소수점형 : 3.14
    - 허수형 : 3 + 2j : i대신 j로 표기함
- 정수형 : 길이 무제한, 메모리 허용범위까지 사용가능, 양의정수, 0, 음의정수
    - 0o 접두어 : 8진수 사용가능
    - 0x 접두어 : 16진수 사용가능
    - 0b 접두어 : 2진수 사용가능
    - 언더스코어는 무시된다. : 100_00 = 10000
- 부동소수점형 : 양과 음의 부동소수점 표현
    - 10. : 소수부 생략 가능
    - .001 : 정수부 생략 가능 
    - 지수 표기법 : 매우 큰수와 매우 정밀한 수의 표기를 위한 방법 : 1e100-10
    - 언더스코어 무시
- 허수형 : j접미사 사용, 언더스코어 무시됨

### 3-3. 문자열
- 문자들의 집합
    - ""
    - ''
- 자료형으로서의 문자형은 제공하지 않음, 길이에 상관없이 모두 문자열
- " 'A' " : 가능
- ' "A" ' : 가능 
- ' 'A' ' : 에러
    - 이스케이프 시퀀스 기호 쓰면 사용 가능 : ' \'A\' '
- " "A" " : 에러
    - 이스케이프 시퀀스 기호 쓰면 사용 가능 : " \"A\" "
- """안녕하세요""" : 이스케이프 시퀀스 사용한 것과 같음
- '''안녕하세요''' : 이스케이프 시퀀스 사용한 것과 같음

### 3-4. 이스케이프 시퀀스 
- 프로그램의 소스 코드 내에서 사용할 수 있도록 백슬래시 기호와 조합해서 사용하는 사전에 정의해둔 문자 조합
- 문자열의 출력 결과 제어를 위해 사용함
- 백슬래시 2개 : 백슬래시 한개 \
    - 따옴표 출력할 때는 한 개 사용
- \n : 줄바꿈
- \t : 수평탭 : 탭만큼 공백

```python
print("안녕하세요 \\")

>>> print

안녕하세요 \
```

```python
print("***\t***\t***\n***\t***\t***")

>>> print

***	***	***
***	***	***
```
### 3-5. 문자열 포멧팅
- 문자열 내에 사용된 문자열 표시 유형(문자열 포멧 코드)을 특정 값으로 변경하는 기법
    - % 포멧팅
    - str.format()
- % 포멧팅
    - %s : 문자열 포멧 
        - % 다음에 오는 값을 문자열로 바꾼다.
    - %c : 문자포멧, 정수를 유니코드로 변화해서 출력 : 97 -> a
    - %d : 10진 정수로 출력 : 97 -> 97 : 부동소수점이면 정수부만 출력해줌
    - %o : 8진수로 출력
    - %x : 16진수로 출력
    - %f : 부동소수점 숫자로 출력, 소수점 이하 6자리 기본값
        - 부동소수점 숫자를 문자열로 변환해준다.
    - %% : %문자 자체를 출력
    - ord() : 문자열을 10진 정수값으로 변환해줌
- 문자열 출력 폭과 정렬 방향
    - "%10s" : 폭 10, 정렬 방향 우측, "공백6개+문자열4개"
        - "%-10s" : 폭 10, 정렬 방향 좌측, "문자열4개+공백6개"
    - "%0.2f" : 소수점 2자리까지 표시  
    - "%10.2f" : 폭 10, 소수점 2자리까지 표시
    - "%010.2f" : 폭 10, 소수점 2자리까지 표시, 공백을 0으로 채운다.
- str.format() 
    - format 함수의 인자의 인덱스가 중괄호로 {} 정해져 있다.
    - {} 위치 인덱스 없으면 순서데로 출력
    - {0:c} : 유니코드로 출력
    - 이름=값 형식으로 인자를 사용할 수 있다. : format(name="홍길동", age=20)
    - "{0:<10}.fomrat()" : 폭 10, < 좌측정렬, > 우측정렬
    - "{0:^10}.format()" : 폭 10, ^ 중앙정렬
    - "{0:*^10}.format()" : 폭 10, ^ 중앙정렬, * 공백채우는 문자
    - "{0:0.2f}.format()" : 소수점 이하 2자리까지 
    - "{0:10.2f}.fomrat()" : 폭 10, 소수점 이하 2자리까지
    - "{0:010.2f}.format()" : 폭 10, 소수점 이하 2자리까지, 공백을 0으로 채움
    - "{{ {0:.1f} }}.format(98.5)" : '{ 98.5 }'

#### % 포멧팅 : ord() 사용

```python
"%s %d %x" % ("가", ord("가"), ord("가"))

>>> print
```

#### % 포멧팅 :  정렬

```python
print("%10s" % "우측정렬")

>>> print

      우측정렬
```

```python
print("%-10s" % "좌측정렬")

>>> print

좌측정렬
```

#### % 포멧팅 : 폭, 공백문자 지정
- 폭 10
- 공백 채울 문자 0
- 소수점 이하 2자리까지 표시

```python
print("%010.2f" % 3.1234)

>>> print

0000003.12
```

#### str.format() : ord() 사용

```python
print("{0}, {1}, {2:x}".format("가", ord("가"), ord("가")))

>>> print

가, 44032, ac00
```

#### str.fromat() : 정렬

```python
print("{0:<10}".format("좌측정렬"))

>>> print

좌측정렬
```

```python
print("{0:<10}".format("우측정렬"))

>>> print

      우측정렬
```

```python
print("{0:^10}".format("중앙정렬"))

>>> print

   중앙정렬
```

```python
print("{0:*^10}".format("중앙정렬"))

>>> print

***중앙정렬***
```
### 3-6. 주석
- 프로그램의 코드 앞에 #을 붙여 작성된 부분으로 소스코드에 대한 상세 설명을 달거나 특정 코드를 실행하지 않을 목적으로 사용함
    - 코드 앞에 # 입력
  
## 4. 변수
- 어떤 값을 저장하는 그릇
    - 값을 저장할 때 사용하는 식별자 : 
    - 변수명 = 값
    - 정수형 변수, 문자열 변수, 리스트 변수
- type() 함수로 변수의 자료형을 확인 할 수 있다.
    - 동적 타이핑 언어의 특징
    - 저장된 값의 자료형에 의해 변수 자료형이 결정되기때문
    - 따라서 변수의 자료형이 얼마든지 바뀔 수 있다. 저장되는 값의 자료형때문에.
- 변수명 : 문자, 숫자, 밑줄을 조합하여 사용
    - 숫자로 시작하는 변수는 만들 수 없다.
    - 대소문자 구분 해야한다.
    - 파이썬 3은 한글 변수명 사용가능
- 파이썬의 예약어는 변수명으로 사용할 수 없다.
    - False, class, finally, is, return, None, continue, for, lambda, try, True, def, from, nonlocal, while, and, del, global, not, with, as, elif, if, or, yield, assert, else, import, pass, break, except, in, raise

### 4-1. 변수와 객체
- 값, 컨테이너, 함수, 클래스
- 변수에 값을 저장한다는 의미
    - 메모리 공간에 값을 가진 객체가 생성되고
    - 변수명이 이 객체를 참조하게 된다.
    - 변수 선언, 값 참조, 값 저장
    
### 4-2. 변수와 자료형
- `부울형 Bool, T, F` : 참, 거짓을 판단하는 표현식에 사용하는 자료형
    - True, False 값
    - 관계 연산자, 논리 연산자, 조건문을 사용하는 표현식이 Bool 값을 반환한다.
- `튜플 Tuple ()` : () 안에 서로 다른 자료형의 값을 콤마로 구분해 하나 이상 저장할 수 있는 컬렉션 자료형
    - 괄호 생략할 수 있다.
    - 0부터 시작하는 인덱스를 이용해 접근할 수 있다.
    - 한번 저장된 항목은 변경할 수 없다.
- `리스트 List []` : 꺽쇠괄호 안에 서로 다른 자료형의 값을 콤마로 구분해 하나 이상 저장할 수 있는 컬렉션 자료형
    - 0부터 시작하는 인덱스를 이용해 접근할 수 있다.
    - 한 번 저장 된 항목이라도 변경 할 수 있다.
- `셋 set {}` : {} 안에 서로 다른 자료형의 값을 콤마로 구분해 하나 이상 저장할 수 있는 컬렉션 자료형
    - 순서의 개념이 존재하지 않으므로 인덱스를 사용할 수 없다.
    - 데이터 항목의 중복을 허용하지 않는다.
    - |= : 데이터 추가, set 끼리 합칠 수 있음, 집합의 더하기 
        - s = {"a", "b"}, s |= {"b", "c"} -> s = {"a", "b", "c"}
- `딕셔너리 dictionay {}` : 키:값 형식, 콤마로 구분해서 하나 이상 저장 할 수 있는 컬렉션 자료형
    - 키를 이용해 값을 읽어 올 수 있다. 인덱스 번호로 값을 읽어 올 수 없다.
    - 항목 추가 시 : 동일키 없으면 새로운 항목 추가, 동일 키 있으면 저장항목 변경
    - 문자열, 정수형 자료형 사용
- `None` : None 객체를 이용해 null 객체 상태를 표현 할 수 있다.
    - null : 객체가 존재하지 않는 상태
    - 최초 변수를 선언할 때 초기화를 하지 않으면 에러 발생
    - 초기화값을 제공하지 않을 경우엔 None 객체 저장 필요
    - **None 값은 False를 반환한다.** : 조건문에서 False 변수로 사용할 수 있음.
- "==" 연산자 : 동일한 값 검사
- "is" 연산자 : 동일 객체 여부 검사

#### None 형 변수 선언
- 변수를 None 값으로 저장하면 아무런 값도 안나온다.

```python
obj = None
obj

>>> print

```
- None 값은 불리언으로 치면 False와 같다.

```python
if obj :
    print("obj는 None이 아니다.")
else :
    print("obj는 None 이다.")

>>> print

obj는 None 이다.
```

### 4-3. 변수의 생성 및 제거
- 변수 생성 : = 을 사용하여 변수생성, 선언, 값저장
    - 한 번에 하나의 변수 생성
    - 여러 변수를 한번에 생성 가능 
    - 튜플, 리스트를 사용하여 변수 생성, 변경 가능
- 변수 제거 : garbage collector에 의해 메모리 관리 자동
    - 객체가 사용한 메모리 공간을 자동으로 관리 해준다.
    - 개발자가 메모리 관리를 직접 할 필요 없다.
    - del() : 사용하지 않는 변수 제거 가능

#### 변수선언

```python
x = y = 100
x

>>> print

100
```
```python
x, y = 10, 20
x

>>> print
 10
```

#### 튜플사용 변수 선언

```python
x, y = (100, 200)
x

>>> print

100
```
```python
(x, y) = (0, 0)
x

>>> print

0
```

#### 리스트 사용 변수 선언

```python
x, y = [5, 10]
x

>>> print

5
```

- x, y 변수의 값 교체

```python
x, y = y, x
x

>>> print

10
```
## 5. 연산자
- 3+2=5
    - 3,2 : 피연산자
    - + : 연산자
- 프로그래밍에서도 연산자를 사용해 연산이 논리적으로 움직이도록 지시한다.
    - 프로그램 로직의 필수 요소

### 5-1. 산술 연산자
- `+, -, *, /`
- `//` : 몫
- `%` : 나머지
- `**` : 제곱
- 산술 연산자 우선순위
    - `+, -` 는 우선순위가 동일하다.
    - `+, -` 는 다른 산술연산자보다 우선순위가 낮다.
    - `*, /` 는 우선순위 동일
    - `()`는 연산의 우선순위가 높다.
- 문자형과 숫자형 연산
    - 문자열 접합 연산 : 문자열을 연결해 새로운 문자열을 만들어 준다.

### 5-2. 대입 연산자
- 변수선언, 연산결과를 변수에 저장, 함수 반환값을 변수에 저장
- `=` : 대입 할당
- `+=` : 복합대입 연산자 : 좌변의 변수에서 우변의 값을 더해서 좌변의 변수에 대입
- `-=` : 복합대입 연산자 : 좌변의 변수에서 우변의 값을 빼서 좌변의 변수에 대입
- `*=` : 복합대입 연산자 : 좌변의 변수에서 우변을 값을 곱해서 좌변의 변수에 대입
- `/=` : 복합대입 연산자 : 좌변의 변수를 우변의 값으로 나누어 좌변의 변수에 대입
- `//=` : 복합대입 연산자 : 좌변의 변수를 우변의 값으로 나눈 몫을 좌변의 변수에 대입
- `%=` : 복합대입 연산자 : 좌변의 변수를 우변의 값으로 나눈 나머지를 좌변의 변수에 대입
- `**=` : 복합대입 연산자 : 좌변의 변수를 우변의 값으로 제곱해서 좌변의 변수에 대입

### 5-3. 관계 연산자
- 값을 비교하는 연산
- `==` : 동등연산자 : 양변의 값이 같으면 True를 반환
- `!=` : 비동등연산자 : 양변의 값이 다르면 True를 반환
- `>` : 좌변의 값이 우변의 값보다 크면 True를 반환
- `<` : 좌변의 값이 우변의 값보다 작으면 True를 반환
- `>=` : 좌변의 값이 우변의 값보다 크거나 같으면 True를 반환
- `<=` : 좌변의 갑싱 우변의 값보다 작거나 같으면 True를 반환
- 변수를 범위로 나타낼 수 있다.

### 5-4. 논리 연산자
- 선택의 문제에서 특정 조건을 만족하는지를 검사하기 위한 조건식을 만들 때 사용
- `and` : 논리곱 연산자 : 양변의 값 모두 True일 경우에만 True를 반환, 두 값이 다르면 False 반환
- `or` : 논리합 연산자 : 양변의 값 모두 False일 경우에만 False를 반환, 다른 경우는 False 반환
- `not` : 부정 연산자 : True 이면 False, False 이면 True를 반환
- **관계연산이 논린연산보다 우선한다.**
    - **not 이 and, or 보다 우선한다.**
    
### 5-5. 비트 연산자
- 0과 1을 반환한다. 
- `&` : 양변의 비트 값 모두 1일 경우에만 1을 반환한다. 
     - 비트논리곱
- `|` : 파이프 연산자 : 양변의 값 모두 0일 경우에만 0을 반환한다. 
    - 비트논리합
- `^` : 캐럿 연산자 : 양변의 값이 다를 경우 1, 같을 경우 0을 반환한다.
    - 비트배타적논리합
- `~` : 틸드 연산자 : 비트값이 1일 경우 0, 0일 경우 1을 반환한다.
    - 비트부정연산
- `<<` : 좌변의 값을 우변의 값 만큼 비트를 왼쪽으로 이동시킨다.
- `>>` : 좌변의 값을 우변의 값 만큼 비트를 오른쪽으로 이동시킨다.
- 비트 연산자 사용 : a=2, b=3
    - a와 b의 2진수를 각 자리별로 비교한 값을 10진수로 나타내준다.
    - a & b : 0010 & 0011 : 0010 -> 2
    - a | b : 0010 | 0011 : 0011 -> 3
    - a ^ b : 0010 ^ 0011 : 0001 -> 1
    - ~a : ~0010 : 1101 -> -3
- 비트 시프트 연산자 : a=8, 8진수 0000 1000
    - a >> 1 : 오른쪽으로 한칸이동, 0000 0100 -> 4
    - **>> 은 오른쪽 이동할 때마다, 정수값을 반으로 줄이는 결과를 만들어 준다.**
    - a << 1 : 오른쪽으로 한칸 이동, 0001 0000 -> 16
    - **<< 은 왼쪽 이동할 때마다, 정수값을 두배한 결과를 만들어 준다.**
    
### 5-6. 연산자 우선 순위
- 괄호가 최우선
- 산술연산이 비트연산보다 우선
- 관계연산이 논리연산보다 우선
- 우선순위
    - `()`
    - `**`
    - `+, -, ~` : 부호, 비트부정
    - `*, /, //, %`
    - `+, -`
    - `<<, >>` : 비트 시프트
    - `&`
    - `^`
    - `|`
    - `<, <=, >, >=, ==, !=`
    - `not` : 부정
    - `and` : 논리곱
    - `or` : 논리합

### 5-7. 연산자 문제
- 인치를 센티미터로 변환하는 프로그램
- 1인치=2.54센티미터

```python
a = float(input())
result = a * 2.54
print("{0:.2f} inch => {1} cm".format(a, result))

>>> print

3.0
3.00 inch => 7.62 cm
```

### 5-8. 연산자 문제
- 킬로그램을 파운드로 변환하는 프로그램 
- 1킬로그램=2.2046파운드

```python
a = float(input())
result = a * 2.2046
print("{0:.2f} kg =>  {1:.2f} lb".format(a, result))

>>> print

0.5555
0.56 kg => 1.22 lb
```

### 5-9. 연산자 문제
- 섭씨를 화씨로 변환하는 프로그램
- 물의 빙점 화씨 32도, 비등점 화씨 212도(표준기압에서)
- 물의 비등점과 빙점의 차이 180도
- 화씨 눈금에서의 간격은 물의 빙점과 비등점 사이의 간격의 1/180

```python
c = int(input())
f = (c * (180/100)) + 32
print("{0:.2f} ℃ =>  {1:.2f} ℉".format(c, f))

>>> print

28
28.00 ℃ =>  82.40 ℉
```

### 5-10. 연산자 문제
- 화씨를 섭씨로 변환하는 프로그램

```python
f = int(input())
c = (f - 32) / (180/100)
print("{0:.2f} ℉ =>  {1:.2f} ℃".format(f, c))

>>> print

82
82.00 ℉ =>  27.78 ℃
```

### 5-11. 연산자 문제
- 20% 농도의 소금물 100g
- 물 200g를 혼합한 소금물의 농도 %를 소수점 두번째 자리까지 구하는 프로그램
- 농도(%) = (용질의 질량 / 용액의 질량) * 100

```python
result = (20 / 300) * 100
print("혼합된 소금물의 농도: {:.2f}%".format(result))

>>> print

혼합된 소금물의 농도: 6.67%
```
## 6. 흐름제어 : if
- 조건문 : if 문
    - 어떤 조건을 만족하는 경우 명령문을 수행하기 위해 사용한다.
    - 조건문의 결과는 T, F를 반환한다.
    - 조건문이 T 이면 명령문을 실행한다.
    - 조건문이 F 이면 명령문을 실행하지 않고, 조건문의 제어를 벗어나게 된다.

### 6-1. if문의 문법
- 명령문은 공백 4개 또는 탭 1번으로 들여쓰기 해야함 : 동일 들여쓰기
    - 들여쓰기가 잘 못 된 경우 : indenttionerror 발생
- 명령문들이 "코드블록"이 된다.
    - if 문이 T인 경우 실행되는 실행문들

```
if 조건식작성 : 
    명령문
    명령문
    명령문
    명령문
```

- if문을 한 줄로 작성 해도 된다.
    - 가독성 나쁘면 줄 바꿔서 작성해야한다.

### 6-2. if 문 블록의 다양한 명령문
- 할당문 : 변수선언과 같음
    - 한줄로 작성할 때는 문장 구분기호 세미콜론 ; 을 써야 함
- 할당문을 if문 밖에서 만들고 T, F에 따라서 출력을 다르게 할 수 있다.
    - if문의 블록을 통과하느냐 통과하지 못하냐에 따라서 명령문을 실행이 다르다.
    
### 6-3. if, else 문
- 어떤 조건을 만족하는 경우의 명령문과 만족하지 않았을 경우이 명령문을 상호배타적으로 수행하고자 할 때 사용
    - if조건식의 결과가 T 이면 명령문 1 실행
    - if조건식의 결과가 F 이면 명령문 2 실행
    - if, else 문의 명령문 들여쓰기는 동일해야한다.
- 특정 조건에 따라 변수의 값만 변경이 필요한 경우
    - result = "합격" if score >= 60 else "불합격"
    - 변수 선언을 if, else 문으로 하면, 조건에 따라 다른 값이 저장 된다.
    
### 6-4. if, elif, else 문
- 2개 이상의 다중 조건을 처리하고자 할 때 사용
    - if 조건식이 False 인 경우 elif 조건식 실행
    - elif 조건식이 False 인 경우 else 조건식 실행
    - elif 조건식은 여러개 쓸 수 있다.

### 6-5. input()
- 문자열 전달
- 표준출력(콘솔, 터미널)에 문자열 출력
- 표준입력(키보드)로부터 입력된 값을 반환
- 문자열을 어떤 자료형으로 변환할 지 설정 할 수 있다.
    - int(input()) : 문자열이 int 자료형으로 변환된다.

#### 계산기 만들기

```python
operand1, operator, operand2 = 0, "", 0
operand1 = int(input("첫 번째 숫자를 입력하세요 : "))
operator = input("연사자를 입력하세요 (+, -, *, /) : ")
operand2 = int(input("두 번째 숫자를 입력하세요 : "))

if operator == "+" :
    print("%d + %d = %d" % (operand1, operand2, operand1 + operand2))
elif operator == "-" :
    print("%d - %d = %d" % (operand1, operand2, operand1 - operand2))
elif operator == "*" :
    print("%d * %d = %d" % (operand1, operand2, operand1 * operand2))
elif operator == "/" :
    print("%d / %d = %.2f" % (operand1, operand2, operand1 / operand2))
else :
    print(" '%s'는 지원하지 않는 연산자입니다." % operator)

>>> print

첫 번째 숫자를 입력하세요 : 2
연사자를 입력하세요 (+, -, *, /) : /
두 번째 숫자를 입력하세요 : 3
2 / 3 = 0.67
```

### 6-6. 흐름제어 if : 연습문제 1
- 임의의 양의 정수를 입력받아 그 정수의 모든 약수를 구하라

```python
num = int(input())
for i in range(1, num+1) :
    if num % i == 0 :
        print("%d(은)는 %d의 약수입니다." % (i, num))

>>> print

9
1(은)는 9의 약수입니다.
3(은)는 9의 약수입니다.
9(은)는 9의 약수입니다.
```

### 6-7. 흐름제어 if : 연습문제 2
- 임의의 양의 정수를 입력받아 그 정수의 모든 약수를 구하라.
- 약수가 2개일 경우 소수임을 나타내라.

```python
num = int(input())
count = 0
temp = []

i = 1
while i <= num :
    if num % i == 0 :
        count += 1
        print("{0}(은)는 {1}의 약수입니다.".format(i, num))
        temp.append(i)
    i += 1

if count == 2 :
    print("{0}(은)는 {1}과 {2}로만 나눌 수 있는 소수입니다."\
          .format(num, temp[0], temp[1]))

>>> print

9
1(은)는 9의 약수입니다.
3(은)는 9의 약수입니다.
9(은)는 9의 약수입니다.
```

### 6-8. 흐름제어 if : 연습문제 3
- 입력된 알파벳 문자에 대해 대소문자를 구분하는 코드를 작성하라.

```python
s = input()

if s == s.lower() :
    print("%s 는 소문자 입니다." % s)
else :
    pass

>>> print

a
a 는 소문자 입니다.
```

### 6-9. 흐름제어 if : 연습문제 4
- 두 사람이 가위바위보를 해서 승패를 가르는 게임으로 프로그래밍 하시오.
- ["가위", "바위", "보"] 리스트 사용
- 입력 : 두 줄에 ["가위", "바위", "보"] 중 하나가 차례로 주어진다
- 첫번째 사람 : Man1
- 두번째 사람 : Man2
- 이긴 사람의 결과 출력
- Man1 이 이긴 경우 결과
    - Reseult : Man1 Win! 출력
- 비긴 경우 
    - Result : Draw 출력

```python
Man1 = input()
Man2 = input()
act_lst = ["가위", "바위", "보"]

if Man1 == act_lst[0] :
    if Man2 == act_lst[0] :
        print("Result : Draw")
    elif Man2 == act_lst[1] :
        print("Result : Man2 Win!")
    elif Man2 == act_lst[2] :
        print("Result : Man1 Win!")
elif Man1 == act_lst[1] :
    if Man2 == act_lst[0] :
        print("Result : Man1 Win!")
    elif Man2 == act_lst[1] :
        print("Result : Draw")
    elif Man2 == act_lst[2] :
        print("Result : Man2 Win!")
else :
    if Man2 == act_lst[0] :
        print("Result : Man2 Win!")
    elif Man2 == act_lst[1] :
        print("Result : Man1 Win!")
    elif Man2 == act_lst[2] :
        print("Result : Draw")

>>> print

가위
가위
Result : Draw

>>> print

바위
보
Result : Man2 Win!
```

### 6-10. 흐름제어 if : 연습문제 5
- 입력된 문자가 대문자일 경우 소문자로, 소문자일 경우 대문자로 변경하라.
- 알파벳이 아닌 경우 그냥 출력하는 코드를 작성하라.
- 출력시 아스키코드를 함께 출력한다.
- **문자열 -> 아스키 코드 : ord("문자열")**
- **아스키코드 -> 문자열 : chr(아스키코드)**


#### 아스키 코드와 문자열 확인
- 대문자 : 65~90

```python
for i in range(65, 91) :
    print(chr(i), end="  ")

>>> print

A  B  C  D  E  F  G  H  I  J  K  L  M  N  O  P  Q  R  S  T  U  V  W  X  Y  Z
```

- 소문자 : 97~122

```python
for i in range(97, 123) : 
    print(chr(i), end="  ")

>>> print

a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z
```

#### 아스키코드 변환을 사용한 대소문자 전환 코드

```python
s = input()
big_alphabet = range(65, 91)
small_alphabet = range(97, 123)

if ord(s) in big_alphabet :
    after_s = s.lower()
    print("%s(ASCII: %d) => %s(ASCII: %d)" % (s, ord(s), after_s, ord(after_s)))
elif ord(s) in small_alphabet :
    after_s = s.upper()
    print("%s(ASCII: %d) => %s(ASCII: %d)" % (s, ord(s), after_s, ord(after_s)))
else :
    print(s)

>>> print

c
c(ASCII: 99) => C(ASCII: 67)
```

### 6-11. 흐름제어 if : 연습문제 6
- 1~200 사이의 정수 가운데 7의 배수이면서 5의 배수는 아닌 모든 숫자들을 찾아라.
- 콤마로 구분된 문자열을 출력하는 프로그램을 작성하라.
- 마지막에 콤마를 출력하지 않는 다른 조건식은 없을까???

```python
i = 1
while i <= 200 :
    if (i % 7 == 0) and (i % 5 != 0) :
        if i != 196 :
            print(i, end=",")
        elif i == 196 :
            print(i)
    else :
        pass
    i += 1

>>> print

7,14,21,28,42,49,56,63,77,84,91,98,112,119,126,133,147,154,161,168,182,189,196
```

#### 마지막에 콤마를 제거하기 위한 다른 코드
- 해당 숫자들을 리스트에 넣고, 하나씩 출력한다.
- 마지막 인덱스인 경우 콤마 출력을 하지 않는 조건을 넣는다.

```python
num_lst = []

i = 1
while i <= 200 :
    if (i % 7 == 0) and (i % 5 != 0) :
        num_lst.append(i)
    else :
        pass
    i += 1

j = 0
while j < len(num_lst) :
    if j != len(num_lst) - 1 :
        print(num_lst[j], end=",")
    else :
        print(num_lst[j])
    j += 1

>>> print

7,14,21,28,42,49,56,63,77,84,91,98,112,119,126,133,147,154,161,168,182,189,196
```

### 6-12. 흐름제어 if : 연습문제 7
- 100~300 사이의 숫자에서 각각의 자리 숫자가 짝수인 숫자를 찾아 콤마로 출력하라.

#### 값을 str로 변경 후 자리별로 짝수 확인하는 코드
- str로 변환
- 인덱싱으로 자리별 값 선택 -> int로 변환 -> 짝수 확인
- 각 자리별로 확인

```python
j = 100
while j <= 300 :
    str_j = str(j)
    if int(str_j[0]) % 2 == 0 :
        if int(str_j[1]) % 2 == 0 :
            if int(str_j[2]) % 2 == 0 :
                if j != 288 :
                    print(j, end=",")
                else :
                    print(j)
    else :
        pass
    j += 1

>>> print

200,202,204,206,208,220,222,224,226,228,240,242,244,246,248,260,262,264,266,268,280,282,284,286,288
```

- if 문을 and 로 연결하여 정리한 코드 : 결과는 동일함

```python
j = 100
while j <= 300 :
    str_j = str(j)
    if (int(str_j[0]) % 2 == 0) and (int(str_j[1]) % 2 == 0) and (int(str_j[2]) % 2 == 0) :
        if j != 288 :
            print(j, end=",")
        else :
            print(j)
    else :
        pass
    j += 1
    
>>> print

200,202,204,206,208,220,222,224,226,228,240,242,244,246,248,260,262,264,266,268,280,282,284,286,288
```

#### 자리수를 각각 변수에 저장 후 한번에 짝수 확인
- 어떤 숫자를 % 10 하면 마지막 자리 숫자가 나머지 값으로 출력된다.
- 어떤 숫자를 10의 거듭제곱으로 나누면 마지막 자리수가 줄어든다.
    - 3자리수 -> 2자리수
    - 4자리수 -> 3자리수

```python
t = 100

while t <= 300 :
    first = int(t/1) % 10
    second = int(t/10) % 10
    third = int(t/100) % 10
    if (first % 2 == 0) and (second % 2 == 0) and (third % 2 == 0) :
        if t != 288 :
            print(t, end=",")
        else :
            print(t)
    else :
        pass
    t += 1

>>> print

200,202,204,206,208,220,222,224,226,228,240,242,244,246,248,260,262,264,266,268,280,282,284,286,288
```
