# 컴퓨터를 활용한 사고
- (학습자료가 따로 있음)
- s/w에 대한 예측과 확인에 대한 훈련이 되어 있지 않으면 단순 작업 이상의 코드를 작성하기 어렵다.
- s/w problem solving
- 기초 논리와 수학
- 머리속으로 생각한 것을 실제 코드로 옮기는 연습

## 0. 프로그래밍과 논리/수학
- 프로그래밍은 어렵다
    - 라이브러리 사용, 프로그래밍 문법 어려움
    - 논리적인 어려움, 어렵지 않은 문제여도 논리적인 풀이의 어려움이 있다.
- 직관과 논리    
    - 직관을 이용해 문제를 푸는 경우, 논리를 사용해서 문제를 푸는 경우
    - 카드 앞뒤문제 : D, 3
    - 미성년자와 맥주 문제 
    - 일상속에서 논리적 문제를 풀때 직관을 사용해서 푼다.
    - 직관은 익숙한 상황에서 빠르게 작용한다. 그러나 정확하지 않다. 착각이 심함.
    - 논리, 컴퓨테이션 팅킹은 논리적으로 접근해야 한다.
    - inclusive or, exclusive or의 차이가 언어속에 들어 있지만 직관적으로 이해함
- 직관 : soft logic, 프로그래밍 : hard logic을 사용한다.

## 1. 논리와 증명

### 1-1. 논리
- p이면 q이다. : p가 거짓이면 전체는 참이된다.
    - "만약 0이 홀수라면, 미국에서 2080년 월드컵이 열린다." : T 
    - 가정이 거짓이면 전체 명제는 참이된다.
- p이면 q이다. : q가 참이면 전체는 참이된다.
    - p가 사실이 아니어도 q가 참이면 전체는 참이다.
    - "만약 18293729374이 prime number이면 2는 짝수이다."
    - 앞의 수가 prime number인지 아닌지 모르지만, 뒤가 참이니까 전체는 참이다.
- p -> q 가 거짓인 경우
    - p가 참이고 q가 거짓인 경우만 가능하다.
    - p가 거짓이면 전체는 참
    - q가 참이면 전체는 참
- 역, 이, 대우
    - 역 : q -> p
    - 이 : ~p -> ~q
    - 대우 : ~q -> ~p

### 1-2. 증명 : 수학적 귀납법의 사용 
- 증명은 정확한 명제식으로 표현할 수 있는 것
- 명제식까지는 안쓰지만 근본적으로는 명제식으로 바꿀 수 있다.
- 증명에 대한 수 많은 오해 : p -> q 를 p <-> q와 혼동하는 것에서 일어난다.
- 당구공 pradox : 어려운 문제
    - "모든 당구공은 색이 같다"는 것을 논리적으로 증명하는 과정
    - 수학적 귀납법 : p(1)이 참이고, p(n) T -> p(n+1) T이면 모든 자연수 n에 대해서 참이다.
    - p(n)인경우 모든 당구공의 색깔이 같다고 가정, p는 참이든 거짓이든 상관 없다.
    - n+1개의 주머니에서 1개를 빼면, p(n)이니까 색이 같음. 다시 넣고, 새로운 1개를 뺴도 p(n)이니까 색이 같음. 따라서 p(n+1)은 색이 같다고 생각할 수 있다.
    - 그러나 오류가 있다. p(n)이 참이라는 가정이 문제가 아니라, p(n+1)의 예시가 잘 못됨. 1개씩 뺐을때 두 개의 공이 서로 같은 색이라는 것을 증명할 수 없다.
- infinitely many prime numbers
    - "prime number가 무한개이다"라는 명제를 증명하려고 함.
    - prime number의 개수가 유한한 k개라고 가정
- **알고리즘의 정확한 이해를 위해서 상세한 증명을 해보는 연습을 해야함.**

