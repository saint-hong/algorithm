# 컴퓨터를 활용한 사고
- (학습자료가 따로 있음)
- s/w에 대한 예측과 확인에 대한 훈련이 되어 있지 않으면 단순 작업 이상의 코드를 작성하기 어렵다.
- s/w problem solving
- 기초 논리와 수학
- 머리속으로 생각한 것을 실제 코드로 옮기는 연습

## 0. 프로그래밍과 논리/수학
- 프로그래밍은 어렵다
    - 라이브러리 사용, 프로그래밍 문법 어려움
    - 논리적인 어려움, 어렵지 않은 문제여도 논리적인 풀이의 어려움이 있다.
- 직관과 논리    
    - 직관을 이용해 문제를 푸는 경우, 논리를 사용해서 문제를 푸는 경우
    - 카드 앞뒤문제 : D, 3
    - 미성년자와 맥주 문제 
    - 일상속에서 논리적 문제를 풀때 직관을 사용해서 푼다.
    - 직관은 익숙한 상황에서 빠르게 작용한다. 그러나 정확하지 않다. 착각이 심함.
    - 논리, 컴퓨테이션 팅킹은 논리적으로 접근해야 한다.
    - inclusive or, exclusive or의 차이가 언어속에 들어 있지만 직관적으로 이해함
- 직관 : soft logic, 프로그래밍 : hard logic을 사용한다.

## 1. 논리와 증명

### 1-1. 논리
- p이면 q이다. : p가 거짓이면 전체는 참이된다.
    - "만약 0이 홀수라면, 미국에서 2080년 월드컵이 열린다." : T 
    - 가정이 거짓이면 전체 명제는 참이된다.
- p이면 q이다. : q가 참이면 전체는 참이된다.
    - p가 사실이 아니어도 q가 참이면 전체는 참이다.
    - "만약 18293729374이 prime number이면 2는 짝수이다."
    - 앞의 수가 prime number인지 아닌지 모르지만, 뒤가 참이니까 전체는 참이다.
- p -> q 가 거짓인 경우
    - p가 참이고 q가 거짓인 경우만 가능하다.
    - p가 거짓이면 전체는 참
    - q가 참이면 전체는 참
- 역, 이, 대우
    - 역 : q -> p
    - 이 : ~p -> ~q
    - 대우 : ~q -> ~p

### 1-2. 증명 : 수학적 귀납법의 사용 
- 증명은 정확한 명제식으로 표현할 수 있는 것
- 명제식까지는 안쓰지만 근본적으로는 명제식으로 바꿀 수 있다.
- 증명에 대한 수 많은 오해 : p -> q 를 p <-> q와 혼동하는 것에서 일어난다.
- 당구공 pradox : 어려운 문제
    - "모든 당구공은 색이 같다"는 것을 논리적으로 증명하는 과정
    - 수학적 귀납법 : p(1)이 참이고, p(n) T -> p(n+1) T이면 모든 자연수 n에 대해서 참이다.
    - p(n)인경우 모든 당구공의 색깔이 같다고 가정, p는 참이든 거짓이든 상관 없다.
    - n+1개의 주머니에서 1개를 빼면, p(n)이니까 색이 같음. 다시 넣고, 새로운 1개를 뺴도 p(n)이니까 색이 같음. 따라서 p(n+1)은 색이 같다고 생각할 수 있다.
    - 그러나 오류가 있다. p(n)이 참이라는 가정이 문제가 아니라, p(n+1)의 예시가 잘 못됨. 1개씩 뺐을때 두 개의 공이 서로 같은 색이라는 것을 증명할 수 없다.
- infinitely many prime numbers
    - "prime number가 무한개이다"라는 명제를 증명하려고 함.
    - prime number의 개수가 유한한 k개라고 가정
- **알고리즘의 정확한 이해를 위해서 상세한 증명을 해보는 연습을 해야함.**

## 2. 수와 표현

### 2-1. 컴퓨터의 비트 표현 원리
- 컴퓨터는 0과 1을 표현할 수 있는 비트들을 모아서 수를 표현한다.
- k개의 비트를 사용하면 0부터 2^k - 1 까지 표현이 가능하다.
    - 5개의 비트를 사용하면 0 부터 31 까지의 표현이 가능하다는 의미
    - 범위는 약속방식에 따라 다름
    - 최대 2^k 가지의 값을 표현할 수 있음

### 2-2. log n의 의미
- 어떤 값 n을 표현하기 위한 비트의 갯수는?
    - 2^k -1 >= n 이 성립해야한다.
    - 2^k >= n+1
    - 양변에 밑이 2인 로그를 씌우면 : k >= log(n+1)
- 따라서 약 log n 의 비트가 필요하다.
- x = log n 과 2^k = n 은 같은 의미이다. 즉 log n의 의미는
    - 2의 몇승을 하면 n이 되는 가의 답 : log n
    - n을 표현하려면 몇 비트가 필요한가의 답 : log n
    - 1로 시작해서 두배를 계속 할 때 몇번하면 n에 가까워지는 가의 답 : log n
    - n을 2로 계속 나눌때 몇번 나누어야 거의 1이 되는가의 답 : log n
- 컴퓨터 분야에서의 로그의 밑은 거의 항상 2 이다.
- 32비트 컴퓨터의 주소 공간은 2^32 = 약 40억개의 주소이다.

## 3. 집합과 조합론

### 3-1. 집합
- 두 집합 A와 B에 대해서 A가 B의 부분집합임을 증명하는 방법 : A의 임의의 원소가 B에 포함된다는 것을 증명
    - 4의 배수가 2의 배수이다를 증명 : 4k = 2(2k)
- 두 집합 A와 B가 같다는 것은 증명하는 방법 : A가 B의 부분집합, B가 A의 부분집합임을 증명
- A={x|x = 2k + 1, k=정수}, B={x|x = 4k + 1 혹은 4k + 3, k=정수} 일 때 두 집합이 같다는 것을 증명하려면?
    - A가 B의 부분 집합, B가 A의 부분집합이라는 명제를 증명한다.
    - A가 B의 부분 집합 : 짝수 2t, 홀수 2t+1을 2k+1에 대입하면 B의 부분집합
    - B가 A의 부분 집합 : 4k+1=2(2k)+1, 4k+3=2(2k+1)+1 이므로 A의 부분집합

### 3-2. 조합
- 조합론은 경우의 수를 따지는 문제
- 조합의 개수는 C를 이용하여 표현 또는 괄호 표현을 더 많이 쓰기도함

## 4. 기초수식
- 알고리즘의 시간 복잡도를 표현하기 위한 다양한 수식들 존재
- 풀이법을 익혀두어야 알고리즘의 시간 복잡도를 계산할 수 있다.
    - 알고리즘이 시간이 얼마나 걸리는지 예측할 수 있다.

## 5. 재귀

### 5-1. 재귀
- 재귀란 자기 자신을 호출하는 함수를 의미한다. 실행이 끝날 수 있는가?
- 함수는 입력을 받는다. 따라서 자기 자신을 입력을 받기위해 자신을 호출하면 끝나지 않는다.
- 다른 입력으로 호출하면 끝남

### 5-2. 함수
- 어떤 문제를 해결하는 방법을 코딩한 것과 같다.
- 함수는 어떤 문제의 모든 케이스들을 해결해야 한다.
- 수학적 귀납법 증명 사용 가능
    - n=0 일 때 문제를 풀 수 있음
    - n-1 에서 문제를 풀 수 있으면 n에서도 문제를 풀 수 있음
    - 위 두가지가 사실이면 모든 가능한 n에 대해 문제를 풀 수 있다는 것
- 피보나치 함수의 원리
- 정렬의 원리
- 시간 복잡도 따져 보기

## 6. 동적 프로그래밍
- 특징 1 : Memoization : 재귀 함수에서 동일한 입력의 함수 호출이 반복적으로 일어날 때, 그 결과 값을 저장해 두고 불러 쓰는 것
- 최초 입력에서 파생되는 모든 가능한 입력에 대한 답을 모두 저장할 수 있는 메모리가 있어야 한다.
- 특징 2: Dynamic Programming : 단순히 재귀에서 저장 된 값을 찾아보는 것으로도 가능하지만, 결과 값을 순서를 정해서 계산할 수도 있다.
- Memoization 피보나치 수열의 원리
- Dynamic Programming 피보나치 수열의 원리
- 시간 복잡도 따져 보기

## 7. 조합론 프로그램 과제
- 조합을 구현하는 프로그래밍 문제

## 8. 기초 알고리즘 프로그램 과제
- 알고리즘을 구현하는 프로그래밍 문제

