# 021. 최적화한 조합

### 1) 접근풀이 및 조건
- 조합을 코드로 만든 예 2 가지
```
### 조합공식을 순차적으로 연산한 방식

def combi(n, r) :
    i = 1
    p = 1
    while i <= n :
        p = p * (n - i + 1) // i
        i = i + 1
    return p

### 재귀호출을 사용한 방식

def combi_2(n, r) :
    if r == 0 or r == n :
        return 1
    else :
        return combi_2(n-1, r) + combi_2(n-1, r-1)
```
- 재귀호출을 사용한 방식에서 알고리즘의 성능을 높이려면 재귀호출의 횟수를 줄이는 것이 좋다.
    - 10C3을 구하기 위해 재귀호출을 하는 횟수는 200번이 넘는다.
- 조합 공식을 변형하면 재귀호출을 1번으로 줄일 수 있다.
    - n개 중에서 r개를 선택하는 경우와 n개 중에서 r-1개를 선택하는 경우의 공식
    - $f(n,r)=\dfrac{n!}{r!(n-r)!}, \;\; f(n, r-1)=\dfrac{n!}{(r-1)!(n-r+1)!}$
    - 따라서
    - $f(n,r)=\dfrac{n!}{(r-1)!(n-r+1)!}\cdot\dfrac{n-r+1}{r}$

### 2) 코드

#### 재귀호출을 2번 사용한 코드
- n과 r을 줄여가면서 재귀호출을 하기 때문에 실제 재귀호출이 작동하는 횟수는 많다.

```
counter = 0
def combi(n, r) :
    global counter

    counter += 1
    print(counter)
    print(n, r)

    if r == n or r == 0 :
        return 1
    else :
        return combi(n-1, r) + combi(n-1, r-1)
```
- 20C5의 조합
```
combi(20, 5)

=====<print>=====

15504
```
- 조합을 계산한 횟수 확인
```
counter 

=====<print>=====

31007
```
#### 위의 변형 공식을 사용하면 재귀호출을 1번으로 줄일 수 있다.
- 재귀호출 실행 횟수가 크게 작아진다.
- r! 횟수만 호출하면 된다.
```
counter = 0

def combi_optimization(n, r) :
    global counter

    counter += 1
    print(counter)
    print(n, r)
    if r == n :
        return 1
    elif r == 1 :
        return n
    else :
        return combi_optimization(n, r-1) * (n-r+1) // r
```
- 조합의 경우의 수를 찾는 과정이 훨씬 간단해졌다.
```
combi_optimization(20, 5)

=====<print>=====

1
20 5
2
20 4
3
20 3
4
20 2
5
20 1

15504
```
```
counter 

=====<print>=====

5
```
# 022. 대리석 채우기

### 1) 접근풀이 및 조건
- 2xn의 벽면에 대리석 조각을 붙이는 경우의 수를 구하는 것
    - 세로 2, 가로 n 개 형태의 벽
    - 대리석 조각은 2 x 1 , 1 x 2 , 2 x 2 의 형태
- f(0) = 1 : 벽면이 0 일 경우, 벽면을 아무것도 채우지 않는 방법은 1 가지이다.
- f(1) = 1 : 벽면이 2x1 일 경우 채우는 방법은 1 가지이다. 2x1 의 조각 사용
- f(2) = 3 : 벽면이 2x2 일 경우 채우는 방법은 3 가지이다.
    - 2x1 두 장을 사용하는 방법, 1x2 두 장을 사용하는 방법, 2x2 한 개로 채우는 방법
- f(n) 을 채우는 경우 :
    - 2x1 조각을 사용하는 경우 : n-1 까지 채운 후 마지막 한 칸을 2x1 로 채운다. 즉 f(n-1) 의 경우의 수와 같다.
    - 1x2 조각을 사용하는 경우 : n-2 까지 채운 후 1x2 조각을 두 개 사용하여 채운다. 즉 f(n-2) 의 경우의 수와 같다. 
    - 2x2 조각을 사용하는 경우 : n-2 까지 채운 후 2x2 조각을 한 개 사용하여 채운다. 즉 f(n-2) 의 경우의 수와 같다.
- 즉 점화식을 사용하여 풀이 할 수 있다.
    - ``n <= 1 이면 f(n) = 1 이고, n > 1 이면 f(n) = f(n-1) + f(n-2) + f(n-2) = f(n-1) + 2f(n-2) 가 된다.``
- 조합을 점화식으로 나타내는 것이 핵심

### 2) 코드
- x % 100 : 십의 자리까지의 두 수만 구하는 의미
- 여기에서 왜 x % 100 을 하는지 모르겠음.

```
def solve(k, m) :
    if k <= 1 :
        return 1 % m
    else :
        return (solve(k-1, m) + 2 * solve(k-2, m)) % m

if __name__ == "__main__" :
    n = int(input("n : "))
    m = int(input("m : "))
    print(solve(n, m))

=====<print>=====

n : 2
m : 100
3
```
#### % 100 을 하지 않은 경우

```
def solve_2(k) :
    if k <= 1 :
        return 1
    else :
        return solve_2(k-1) + (2 * solve_2(k-2))


for i in range(20) :
    print(i, solve_2(i))

=====<print>=====

0 1
1 1
2 3
3 5
4 11
5 21
6 43
7 85
8 171
9 341
10 683
11 1365
12 2731
13 5461
14 10923
15 21845
16 43691
17 87381
18 174763
19 349525
```
#### % 100 을 한 경우
- 벽면의 넓이가 넓어질 수록 경우의 수가 많아지는 게 맞는데 왜 % 100 을 써서 십의 자리까지만 표시했는지 모르겠음.

```
for i in range(20) :
    print(i, solve(i, 100))

=====<print>=====

0 1
1 1
2 3
3 5
4 11
5 21
6 43
7 85
8 71
9 41
10 83
11 65
12 31
13 61
14 23
15 45
16 91
17 81
18 63
19 25
```
# 023. 두 수의 차이 구하기

### 1) 접근풀이 및 조건
- 파이썬의 abs() 함수는 어떤 수의 절대값을 구해준다. 두 수의 차이를 구하기 위해 abs() 함수를 사용하지 않고 직접 구현해본다.
- 두 수의 크기를 비교한 후, 상황에 따라서 큰 수에서 작은 수를 빼준다.

### 2) 코드

```
def abs_solve(a, b) :
    if a < b :
        return b - a
    else :
        return a - b
    
if __name__ == "__main__" :
    a = -15
    b = 22
    print("|{0} - {1} = {2}|".format(a, b, abs_solve(a,b)))

=====<print>=====

# 절대값의 형태로 출력된다

|-15 - 22 = 37|
```

- 파이썬의 내장 함수인 abs() 사용하면 특정 숫자의 절대값을 얻을 수 있다.

```
abs(-15)

=====<print>=====

15

abs(-15) - 10

=====<print>=====

5

abs(-15.773)

=====<print>=====

15.773

abs(200)

=====<print>=====

200
```

# 024. 점수분포 출력하기

### 1) 접근풀이 및 조건
- 0점부터 100점의 분포를 출력하기 : 0점대 - 2명, 10점대 - 4명, ... , 90점대 - 3명
- 랜덤하게 만든 배열의 각 데이터의 점수대를 확인 후 카운팅을 하는 방식으로 접근하면 간편하다.
- 조건 :
    - 배열의 데이터를 반복적으로 확인해야하는 작업이므로 배열의 길이를 먼저 따져봐야 한다. 그러나 배열의 길이를 확인 하는 것보다 배열 마지막에 특정값을 추가해주면 더 간편해진다. 
    - 점수를 10으로 나누면 점수대를 확인하기 쉽다. : `25 // 10 = 2`
    - 해당 점수대가 나올 때마다 카운팅을 하는 배열을 하나더 만들면 몇점대에 몇개가 있는지 확인 하기 간편해진다.

### 2) 코드

#### 어떤 배열의 마지막에 -1을 추가
- 랜덤한 길이의 배열과 랜덤한 데이터 만들기
- 길이를 확인하지 않고 배열의 마지막에 데이터 추가하기 : append

```
import random

n = int(random.randint(10, 20))
point = [random.randint(0,100) for _ in range(n)]

print(point, n)

=====<print>=====

# 랜덤하게 만든 숫자 리스트와 숫자의 갯수 출력

[29, 71, 31, 4, 79, 70, 77, 76, 9, 91, 16, 56, 65, 4] 14
```

#### 배열에 데이터를 추가하는 방법은 다양하다.
- insert, append
- stack 이나 queue 패키지도 있음

```
# insert(인덱스, 데이터값) : "Insert object before index." 지정한 인덱스 이전의 위치에 데이터를 삽입해준다. 배열의 오른쪽 끝에는 넣을 수 없다.

point.insert(-1, -2)
point.insert(0, -1)

point

=====<print>=====

[-1, 29, 71, 31, 4, 79, 70, 77, 76, 9, 91, 16, 56, 65, -2, 4]
```
```
# append() : "Append object to the end of the list." 배열의 마지막 인덱스에 데이터를 삽입한다.

point.append(-10)

point

=====<print>

[-1, 29, 71, 31, 4, 79, 70, 77, 76, 9, 91, 16, 56, 65, -2, 4, -10]
```

#### 랜덤한 배열을 만들고 배열의 마지막에 -1 을 삽입

```
n = int(random.randint(20, 30))
point_lst = [random.randint(0, 100) for _ in range(n)]
point_lst.append(-1)

print(point_lst)

=====<print>=====

[63, 99, 99, 38, 95, 15, 72, 78, 3, 73, 11, 5, 70, 97, 77, 10, 64, 49, 63, 9, 38, 28, 99, 12, 6, 19, 29, 35, 37, 99, -1]
```

#### 반복문으로 랜덤한 배열의 데이터가 어떤 점수대인지 확인

```
i = 0
while point_lst[i] != -1 :
    rank = point_lst[i] // 10
    print(rank, end=" ")
    i += 1

=====<print>=====

6 9 9 3 9 1 7 7 0 7 1 0 7 9 7 1 6 4 6 0 3 2 9 1 0 1 2 3 3 9
```

#### 점수대를 저장한 변수의 값에 따라 카운팅을 누적하는 새로운 배열 추가
- 0점~100점대 이므로 총 11개의 배열

```
i = 0
history = [0] * 11
while point_lst[i] != -1 :
    rank = point_lst[i] // 10
    print(rank, end=" ")
    if rank >= 0 and rank <= 10 :
        history[rank] = history[rank] + 1
    i += 1

print("\n")
print(history)

=====<print>=====

# 0은 4개, 1은 5개, 2는 2개 .... 이러한 방식으로 배열에 데이터가 저장된다.

6 9 9 3 9 1 7 7 0 7 1 0 7 9 7 1 6 4 6 0 3 2 9 1 0 1 2 3 3 9

[4, 5, 2, 4, 1, 0, 3, 5, 0, 6, 0]
```

### 3) 최종코드

```
n = int(random.randint(20, 30))
point_list = [random.randint(0,100) for _ in range(n)]
point_list.append(-1)

print("=== 점수 현황 ===")
print(point_list,", ", n, "명")
print("\n")

i = 0
history = [0] * 11
while point_list[i] != -1 :
    rank = point_list[i] // 10
    if rank >= 0 and rank <= 10 :
        history[rank] = history[rank] + 1
    i += 1

print("=== 점수 분포 ===")
print(history)
print("\n")

for i in range(len(history)) :
    print("{0} 점대 : {1} 명".format(i*10, history[i]))

=====<print>=====

=== 점수 현황 ===
[2, 68, 96, 64, 54, 82, 88, 21, 93, 20, 19, 92, 93, 66, 40, 27, 40, 3, 98, 74, 96, 36, 25, 75, 87, 25, 51, -1] ,  27 명


=== 점수 분포 ===
[2, 1, 5, 1, 2, 2, 3, 2, 3, 6, 0]


0 점대 : 2 명
10 점대 : 1 명
20 점대 : 5 명
30 점대 : 1 명
40 점대 : 2 명
50 점대 : 2 명
60 점대 : 3 명
70 점대 : 2 명
80 점대 : 3 명
90 점대 : 6 명
100 점대 : 0 명
```
# 025. 등수구하기

### 1) 접근풀이 및 조건
- 랜덤한 숫자를 담은 배열에서 각 데이터가 전체에서 몇 번째로 큰 수인지를 출력하는 코드
- 조건
    - 현재 점수와 전체 점수의 처음부터 끝까지 반복하여 비교하면서 몇 번째 크기인지 확인
    - 각 점수를 모든 점수와 비교해야하므로 변수를 두개 만들어 반복문으로 증가시킨다.
    - 현재 점수와 다른 점수를 비교하여 값이 작다면 등수를 저장하는 변수에 1을 증가시킨다.

### 2) 코드

#### 랜덤한 숫자의 배열을 만드는 코드

```
n = int(random.randint(15, 20))
lst = [random.randint(1, 100) for _ in range(n)]
lst.append(-1)
print(lst, n)

=====<print>=====

[45, 79, 29, 99, 18, 53, 41, 9, 30, 79, 92, 19, 86, 12, 25, 28, -1] 16
```

#### 현재 점수를 다른 점수들과 비교하는 코드

```
j = 0
current_grade = 55
current_rank = 1
while lst[j] != -1 :           # 점수 배열의 마지막 끝자리 전까지 실행
    if lst[j] > current_grade :
        current_rank += 1      # current_grade 가 작으면 등수가 높아져야하므로 1 증가
        print(lst[j])          # current_grade 보다 큰 숫자만 출력
    j += 1

print(current_rank)

=====<print>=====

79
99
79
92
86
6
```

#### 현재 점수의 인덱스와 다른 점수들의 인덱스를 각각 다른 변수와 반복문으로 증가시킨다.
- 현재 점수 i 변수와 다른 점수 j 변수가 두번째 반복문의 조건문에서 비교된다.
- i와 j를 비교한 후 i가 작을경우 rank 배열의 i번째 값을 +1 시켜준다.

```
i = 0
rank = [0] * n       # n 은 배열의 길이
while lst[i] != -1 :
    rank[i] = 1
    j = 0
    while lst[j] != -1 :
        if lst[j] > lst[i] :
            rank[i] = rank[i] + 1
        j += 1
    i += 1
print(rank)

=====<print>=====

[7, 4, 10, 1, 14, 6, 8, 16, 9, 4, 2, 13, 3, 15, 12, 11]
```
```
n 

=====<print>=====

16
```
### 3) 최종코드

```
n = int(random.randint(15, 20))
point_lst = [random.randint(1, 100) for _ in range(n)]
point_lst.append(-1)

print("=== 점수 현황 ===")
print(point_lst)
print("=== 전체 인원 ===")
print(n)
print("\n")

i = 0
rank = [0] * n
while point_lst[i] != -1 :
    rank[i] = 1
    j = 0
    while point_lst[j] != -1 :
        if point_lst[j] > point_lst[i] :
            rank[i] = rank[i] + 1
        j += 1
    i += 1

for k in range(len(rank)) :
    print("{0} 는 전체에서 {1} 등".format(point_lst[k], rank[k]))


=====<print>=====

=== 점수 현황 ===
[86, 2, 4, 2, 95, 92, 25, 12, 94, 42, 12, 31, 55, 1, 14, 61, 95, 5, 45, 17, -1]
=== 전체 인원 ===
20


86 는 전체에서 5 등
2 는 전체에서 18 등
4 는 전체에서 17 등
2 는 전체에서 18 등
95 는 전체에서 1 등
92 는 전체에서 4 등
25 는 전체에서 11 등
12 는 전체에서 14 등
94 는 전체에서 3 등
42 는 전체에서 9 등
12 는 전체에서 14 등
31 는 전체에서 10 등
55 는 전체에서 7 등
1 는 전체에서 20 등
14 는 전체에서 13 등
61 는 전체에서 6 등
95 는 전체에서 1 등
5 는 전체에서 16 등
45 는 전체에서 8 등
17 는 전체에서 12 등
```

# 026. 배열을 사용하여 16진수 변환하기

### 1) 접근풀이 및 조건
- 파이썬에서 제공하는 16진수 변환 기능이 아닌 배열을 사용하여 16진수로 나타내보기
- 조건
    - 16진수에서 사용하는 숫자와 문자를 배열의 형태로 저장
    - 변환하려는 수를 16으로 나눈 나머지를 인덱스로 사용하면 16진수로 표현하기 쉽다.

### 2) 코드

#### 변환할 숫자를 16으로 나누어 나머지에 해당하는 문자열의 인덱스 값을 출력한다.
- 변환할 숫자를 16으로 나눈 몫을 다시 재귀호출을 하여 16과 나누는 실행을 반복한다.

```
d = "0123456789ABCDEFGHIJ"

def f(n, k) :
    if n > 0 :
        f(n // k, k)
        print(d[n % k], end="")

if __name__ == "__main__" :
    n = int(input("변환할 10진수 숫자 입력 : "))
    k = int(input("변환진수 입력 : "))
    f(n, k)

=====<print>=====

변환할 10진수 숫자 입력 : 12
변환진수 입력 : 16
C
```
```
if __name__ == "__main__" :
    n = int(input("변환할 10진수 숫자 입력 : "))
    k = int(input("변환진수 입력 : "))
    f(n, k)

=====<print>=====

변환할 10진수 숫자 입력 : 230
변환진수 입력 : 16
E6
```

### 3) 파이썬에서 진수 변환
- 각 진수형태 별로 접두어가 붙으며 이 접두어가 진수를 상징함.
    - 2진수 : 0b
    - 8진수 : 0o
    - 16진수 : 0x

#### 내장함수 사용 
- 어떤 진수의 숫자를 2진수, 8진수, 16진수, 10진수로 변환
- bin(), oct(), hex()

```
value = 50

b = bin(value)
o = oct(value)
h = hex(value)

print("2진수  : ", b)
print("8진수  : ", o)
print("16진수 : ", h)

=====<print>=====

2진수  :  0b110010
8진수  :  0o62
16진수 :  0x32
```
```
bin(60), oct(60), hex(60)

=====<print>=====

('0b111100', '0o74', '0x3c')
```
```
# 내장함수에 변환하고 싶은 진수의 숫자를 넣어주면 된다. 10진수는 str 함수 사용

oct(0b110010), hex(0b110010), str(0b110010)

=====<print>=====

('0o62', '0x32', '50')
```

#### format() 내장 함수 사용

```
value = 78

b = format(value, '#b')
o = format(value, '#o')
h = format(value, '#x')
d = format(0b110010, '#d')

print("2진수  : ", b)
print("8진수  : ", o)
print("16진수 : ", h)
print("10진수 : ", d)

=====<print>=====

2진수  :  0b1001110
8진수  :  0o116
16진수 :  0x4e
10진수 :  50
```

#### format 함수 사용시 '#' 을 빼면 앞에 접두어가 빠진 상태로 출력된다.

```
value = 78

b = format(value, 'b')
o = format(value, 'o')
h = format(value, 'x')
d = format(0b1001110, 'd')

print("2진수  : ", b)
print("8진수  : ", o)
print("16진수 : ", h)
print("10진수 : ", d)

=====<print>=====

2진수  :  1001110
8진수  :  116
16진수 :  4e
10진수 :  78
```
```
str(0o55), type(str(0o55))

=====<print>=====

('45', str)

int(str(0o55)), type(int(str(0o55)))

=====<print>=====

(45, int)
```

# 027. 반복문을 사용하여 팩토리얼 출력하기

### 1) 접근풀이 및 조건
- 팩토리얼 : n! = 1 * 2 * 3 * ... * (n-2) * (n-1) * n
- 알고리즘 분야에서 다양한 방식으로 팩토리얼을 사용함
- 반복문을 사용하여 n * (n -1) * (n -2) ... 누적 곱셈으로 나타내면 간편하다.

### 2) 코드

```
def factorial(n) :
    fact = 1
    i = n

    while i > 1 :
        fact = fact * i
        i -= 1
        print(i, "*", fact)

    print("\n")
    print(n, fact)

factorial(5)

=====<print>=====

4 * 5
3 * 20
2 * 60
1 * 120

5 120
```

#### for 문을 사용해서 만들기

```
def facto(n) :
    factorial = 1
    num = n

    if num < 0 :
        print("must be positive")
    elif num == 0 :
        print("factorial = 1")
    else :
        for i in range(1, num+1) :
            factorial = factorial * i

        print(num, factorial)

facto(0)

=====<print>=====

factorial = 1

facto(-2)

=====<print>=====

must be positive

facto(6)

=====<print>======

6 720
```
#### 재귀호출을 사용하면 코드가 간단해진다.
- 상황에 따라서 다르지만 재귀호출을 잘 사용하면 좋다.

```
def facto_2(n) :
    if n < 1 :
        return print("error : ", n)
    elif n == 1 :
        return 1
    else :
        return n * facto_2(n-1)


facto_2(0)

=====<print>=====

error :  0

facto_2(5)

=====<print>=====

120
```

### 3) 최종코드

```
def factorial_2(n) :
    fact = 1
    i = n

    while i > 1 :
        fact = fact * i
        i -= 1

    return fact
```
```
for j in range(21) :
    print("{}! = {}".format(j, factorial_2(j)))

=====<print>=====

0! = 1
1! = 1
2! = 2
3! = 6
4! = 24
5! = 120
6! = 720
7! = 5040
8! = 40320
9! = 362880
10! = 3628800
11! = 39916800
12! = 479001600
13! = 6227020800
14! = 87178291200
15! = 1307674368000
16! = 20922789888000
17! = 355687428096000
18! = 6402373705728000
19! = 121645100408832000
20! = 2432902008176640000
```

# 028. 재귀호출을 사용하여 팩토리얼 출력하기

### 1) 접근풀이 및 조건
- 팩토리얼을 재귀호출을 사용하여 만들어 보기
- 재귀호출을 사용할 때는 종료 조건을 잘 생각해야 한다.

### 3) 코드

#### n = 0 이 되면 재귀호출이 종료되고 1 이 반환된다.

```
def factorial(n) :
    print(n)
    if n == 0 :
        return 1
    else :
        return n * factorial(n-1)

factorial(5)

=====<print>=====

5
4
3
2
1
0
120
```

#### 종료 조건이 n = 1 이면 1 까지만 재귀호출 실행 된다.

```
def factorial_2(n) :
    print(n)
    if n == 1 :
        return 1
    else :
        return n * factorial_2(n-1)

factorial_2(5)

=====<print>=====

5
4
3
2
1

120
```
# 029. 하노이의 탑

### 1) 접근풀이 및 조건
- 알고리즘 고전 문제 중 하나
- 3개의 기둥과 여러개의 크고작은 원판이 있을 때 한 기둥에서 다른 기둥으로 조건에 맞추어 이동시키는 문제
- 조건 :
    - 한번에 하나의 원판만 이동할 수 있다.
    - 큰 원판이 작은 원판 위에 올 수 없다. 항상 작은 원판이 큰 원판 위에 놓여 있어야 한다.
    - 반드시 모든 기둥을 거치지 않아도 된다. 1번 기둥 -> 3번 기둥 이동 가능.

- 원판의 갯수에 따라서 이동하는 횟수가 달라진다. 이동 횟수를 구하는 것이 답이 된다.

### 2) 풀이
- 이동하는 방식을 일반화 시키면 :
    - 1번 기둥에서 2번 기둥으로 n-1 개의 원판을 이동 -> 1번 기둥에서 남은 1개의 원판을 3번 기둥으로 이동 -> 2번 기둥에서 n-1개의 원판을 3번 기둥으로 이동
- 이 방식을 재귀호출을 사용하여 만들면 간편해진다.

### 3) 코드

```
def hanoi_1(n, num1, num2, num3) :
    if n > 0 :
        hanoi_1(n-1, num1, num3, num2)
        print("{}번 원판을 {}에서 {}으로 이동".format(n, num1, num2))
        hanoi_1(n-1, num3, num2, num1)

hanoi_1(3, '기둥1', '기둥2', '기둥3')

=====<print>=====

1번 원판을 기둥1에서 기둥2으로 이동
2번 원판을 기둥1에서 기둥3으로 이동
1번 원판을 기둥2에서 기둥3으로 이동
3번 원판을 기둥1에서 기둥2으로 이동
1번 원판을 기둥3에서 기둥1으로 이동
2번 원판을 기둥3에서 기둥2으로 이동
1번 원판을 기둥1에서 기둥2으로 이동
```

#### 위의 코드 실행과정을 확인, 재귀호출은 간단하지만 변수의 갯수가 많아지면 작동 방식은 복잡해진다.
- 첫번째 재귀호출이 끝날때까지 반복되고, 두번째 재귀호출이 실행된다.
- 처음 재귀호출의 결과들이 순차적으로 반환되면 다시 두번쨰 재귀호출과 첫번째 재귀호출이 조건에 맞을 때까지 실행된다.
- 그래서 각 단계별 재귀호출 실행의 하위 실행들이 늘어나면서 복잡한 실행 과정이 된다.
- 함수의 파라미터가 a,b 이지만 c를 하나 더 추가하면 실행과정은 더 복잡해진다.

```
def test(n, a, b) :
    print("순환   :",n, a, b)
    if n > 0 :
        print("if 통과:", n, a, b)

        test(n-1, a, b)

        print("프린트 :", n, a, b)
        print("===================")

        test(n-1, b, a)

test(3, 'red', 'blue')

=====<print>=====

순환   : 3 red blue
if 통과: 3 red blue
순환   : 2 red blue
if 통과: 2 red blue
순환   : 1 red blue
if 통과: 1 red blue
순환   : 0 red blue
프린트 : 1 red blue
===================
순환   : 0 blue red
프린트 : 2 red blue
===================
순환   : 1 blue red
if 통과: 1 blue red
순환   : 0 blue red
프린트 : 1 blue red
===================
순환   : 0 red blue
프린트 : 3 red blue
===================
순환   : 2 blue red
if 통과: 2 blue red
순환   : 1 blue red
if 통과: 1 blue red
순환   : 0 blue red
프린트 : 1 blue red
===================
순환   : 0 red blue
프린트 : 2 blue red
===================
순환   : 1 red blue
if 통과: 1 red blue
순환   : 0 red blue
프린트 : 1 red blue
===================
순환   : 0 blue red
```
# 030. 이진트리에서 두 노드 사이의 거리 구하기

### 1) 접근풀이 및 조건
- 이진트리의 특징을 사용하여 두 노드 사이의 거리를 구하기
- 이진트리는 모든 노드가 2개 이하의 자식노드를 갖는다.
    - 정이진트리, 포화이진트리, 완전이진트리, 균형이진트리 등이 있다.
- 부모노드 = 자식노드 / 2
- 자식노드 : 왼쪽 = 2 * n , 오른쪽 = 2 * n + 1
- 조건 :
    - 주어진 노드 n의 부모 노드는 n/2 이다
    - 두 노드의 거리는 두 노드가 루트노드가 될 때까지 부모 노드를 구한다

### 2) 코드
- 재귀함수를 사용하여 노드의 거리를 구하면 간단해진다.
- a = b 가 같은 경우는 거리가 0
- a와 b중에서 큰 수는 부모노드로 올라간다 // 2
    - 이것을 반복하면 두 노드가 결국 루트노드가 된다.
- 큰 수가 부모노드가 되면 레벨이 줄어들었기 때문에 거리를 1 증가시켜준다. 

```
def f(a, b) :
    if a == b :
        return 0
    if b > a :
        return f(a, b // 2) + 1
    if a > b :
        return f(a // 2, b) + 1

f(2,3)

=====<print>=====

2
```

```
def node_distance(a, b) :
    print(a, b)
    if a == b :
        print("if a==b")
        return 0
    print(a, b)
    if b > a :
        print("if b > a : 거리 1 추가")
        return node_distance(a, b//2) + 1
    print(a, b)
    if a > b :
        print("if a > b : 거리 1 추가")
        return node_distance(a//2, b) + 1


if __name__ == "__main__" :
    a = int(input("첫번째 노드 : "))
    b = int(input("두번쨰 노드 : "))
    print("\n")
    print("{}와 {}사이의 거리 : {}".format(a, b, node_distance(a,b)))

=====<print>=====

첫번째 노드 : 4
두번쨰 노드 : 7


4 7
4 7
if b > a : 거리 1 추가
4 3
4 3
4 3
if a > b : 거리 1 추가
2 3
2 3
if b > a : 거리 1 추가
2 1
2 1
2 1
if a > b : 거리 1 추가
1 1
if a==b
4와 7사이의 거리 : 4
```
